[
  {
    "name": "AnagramCheck",
    "slug": "anagram-check",
    "metadata": {
      "title": "Anagram Checker",
      "description": "Checks if two strings are anagrams, ignoring case, spaces, and non-alphanumeric characters",
      "concepts": [
        "string manipulation",
        "sorting",
        "hash maps",
        "regular expressions"
      ],
      "timeComplexity": "O(n log n) for sorting, O(n) for hash map",
      "spaceComplexity": "O(n)"
    },
    "examples": [
      {
        "input": [
          "listen",
          "silent"
        ],
        "output": true,
        "description": "Classic pair"
      },
      {
        "input": [
          "hello",
          "world"
        ],
        "output": false,
        "description": "Non-anagram"
      },
      {
        "input": [
          "Tea!",
          "eat"
        ],
        "output": true,
        "description": "With punctuation"
      },
      {
        "input": [
          "",
          ""
        ],
        "output": true,
        "description": "Empty strings"
      },
      {
        "input": [
          "rat1",
          "tar1"
        ],
        "output": true,
        "description": "With numbers"
      },
      {
        "input": [
          "a b c",
          "cba!"
        ],
        "output": true,
        "description": "With spaces"
      }
    ],
    "code": "import { ExerciseMetadata, ExampleCase } from '@interfaces/exercises';\n\n/**\n * Anagram Checker Exercise Implementation\n * \n * DESCRIPTION:\n * Checks if two strings are anagrams, ignoring case, spaces, non-alphanumeric.\n * \n * EXAMPLE:\n * \"listen\", \"silent\" → true\n * \n * CONCEPTS:\n * - String manipulation\n * - Sorting or frequency counting\n * \n * PERFORMANCE:\n * - Time: O(n log n) sorting, O(n) hash map\n * - Space: O(n)\n * \n * Multiple implementations included to show different approaches.\n */\n\nexport function areAnagrams(str1: string, str2: string): boolean {\n  if (typeof str1 !== 'string' || typeof str2 !== 'string') throw new Error(\"Inputs must be strings\");\n  const anagramPreparer = (str: string): string => str.toLowerCase().replace(/[^a-z0-9]/g, '').split('').sort().join('');\n  return anagramPreparer(str1) === anagramPreparer(str2);\n}\n\nexport function areAnagramsHashMap(str1: string, str2: string): boolean {\n  if (typeof str1 !== 'string' || typeof str2 !== 'string') throw new Error(\"Inputs must be strings\");\n  const cleanStr = (str: string) => str.toLowerCase().replace(/[^a-z0-9]/g, '');\n  const s1 = cleanStr(str1);\n  const s2 = cleanStr(str2);\n  if (s1.length !== s2.length) return false;\n  const charCount: { [key: string]: number } = {};\n  for (let char of s1) charCount[char] = (charCount[char] || 0) + 1;\n  for (let char of s2) {\n    if (!charCount[char]) return false;\n    charCount[char]--;\n  }\n  return Object.values(charCount).every(count => count === 0);\n}\n\nexport const metadata: ExerciseMetadata = {\n  title: \"Anagram Checker\",\n  description: \"Checks if two strings are anagrams, ignoring case, spaces, and non-alphanumeric characters\",\n  concepts: [\"string manipulation\", \"sorting\", \"hash maps\", \"regular expressions\"],\n  timeComplexity: \"O(n log n) for sorting, O(n) for hash map\",\n  spaceComplexity: \"O(n)\"\n};\n\nexport const examples: ExampleCase[] = [\n  { input: [\"listen\", \"silent\"], output: true, description: \"Classic pair\" },\n  { input: [\"hello\", \"world\"], output: false, description: \"Non-anagram\" },\n  { input: [\"Tea!\", \"eat\"], output: true, description: \"With punctuation\" },\n  { input: [\"\", \"\"], output: true, description: \"Empty strings\" },\n  { input: [\"rat1\", \"tar1\"], output: true, description: \"With numbers\" },\n  { input: [\"a b c\", \"cba!\"], output: true, description: \"With spaces\" }\n];\n\nexport default { areAnagrams, areAnagramsHashMap, metadata, examples };",
    "functions": [
      "areAnagrams",
      "areAnagramsHashMap"
    ]
  },
  {
    "name": "ArrayDeduper",
    "slug": "array-deduper",
    "metadata": {
      "title": "Array Deduplication",
      "description": "Removes duplicates from an array of numbers or strings",
      "concepts": [
        "array manipulation",
        "hash sets",
        "filtering",
        "reducing"
      ],
      "timeComplexity": "O(n) for Set-based, O(n²) for filter/reduce-based",
      "spaceComplexity": "O(n)"
    },
    "examples": [
      {
        "input": [
          1,
          2,
          2,
          3,
          1
        ],
        "output": [
          1,
          2,
          3
        ],
        "description": "Duplicate numbers"
      },
      {
        "input": [
          "a",
          "b",
          "a",
          "c",
          "b"
        ],
        "output": [
          "a",
          "b",
          "c"
        ],
        "description": "Duplicate strings"
      },
      {
        "input": [],
        "output": [],
        "description": "Empty array"
      },
      {
        "input": [
          1
        ],
        "output": [
          1
        ],
        "description": "Single element"
      },
      {
        "input": [
          1,
          "a",
          1,
          "a",
          2
        ],
        "output": [
          1,
          "a",
          2
        ],
        "description": "Mixed types"
      },
      {
        "input": null,
        "output": {},
        "description": "Invalid input"
      }
    ],
    "code": "import { ExerciseMetadata, ExampleCase } from '@interfaces/exercises';\n\n/**\n * Array Deduplication Exercise Implementation\n * \n * DESCRIPTION:\n * Removes duplicates from an array of numbers or strings, preserving order.\n * \n * EXAMPLE:\n * [1, 2, 2, 3, 1] → [1, 2, 3]\n * \n * CONCEPTS:\n * - Array manipulation\n * - Sets\n * \n * PERFORMANCE:\n * - Time: O(n) Set, O(n²) filter/reduce\n * - Space: O(n)\n * \n * Multiple implementations included to show different approaches.\n */\n\nexport function ArrayDeduplicate(arr: (number | string)[]): (number | string)[] {\n  if (!Array.isArray(arr)) throw new Error(\"Input must be an array\");\n  const seen = new Set();\n  const dedupedArray: (number | string)[] = [];\n  for (const item of arr) {\n    if (!seen.has(item)) {\n      seen.add(item);\n      dedupedArray.push(item);\n    }\n  }\n  return dedupedArray;\n}\n\nexport function ArrayFilterDeduplicate(arr: (number | string)[]): (number | string)[] {\n  if (!Array.isArray(arr)) throw new Error(\"Input must be an array\");\n  return arr.filter((item, index) => arr.indexOf(item) === index);\n}\n\nexport function ArrayReduceDeduplicate(arr: (number | string)[]): (number | string)[] {\n  if (!Array.isArray(arr)) throw new Error(\"Input must be an array\");\n  return arr.reduce((deduped: (number | string)[], item) => {\n    if (!deduped.includes(item)) deduped.push(item);\n    return deduped;\n  }, []);\n}\n\nexport const metadata: ExerciseMetadata = {\n  title: \"Array Deduplication\",\n  description: \"Removes duplicates from an array of numbers or strings\",\n  concepts: [\"array manipulation\", \"hash sets\", \"filtering\", \"reducing\"],\n  timeComplexity: \"O(n) for Set-based, O(n²) for filter/reduce-based\",\n  spaceComplexity: \"O(n)\"\n};\n\nexport const examples: ExampleCase[] = [\n  { input: [1, 2, 2, 3, 1], output: [1, 2, 3], description: \"Duplicate numbers\" },\n  { input: [\"a\", \"b\", \"a\", \"c\", \"b\"], output: [\"a\", \"b\", \"c\"], description: \"Duplicate strings\" },\n  { input: [], output: [], description: \"Empty array\" },\n  { input: [1], output: [1], description: \"Single element\" },\n  { input: [1, \"a\", 1, \"a\", 2], output: [1, \"a\", 2], description: \"Mixed types\" },\n  { input: null, output: new Error(\"Input must be an array\"), description: \"Invalid input\" }\n];\n\nexport default { ArrayDeduplicate, ArrayFilterDeduplicate, ArrayReduceDeduplicate, metadata, examples };",
    "functions": [
      "ArrayDeduplicate",
      "ArrayFilterDeduplicate",
      "ArrayReduceDeduplicate"
    ]
  },
  {
    "name": "BinarySearch",
    "slug": "binary-search",
    "metadata": {
      "title": "Binary Search",
      "description": "Finds the index of a target in a sorted array",
      "concepts": [
        "divide-and-conquer",
        "logarithmic search"
      ],
      "timeComplexity": "O(log n)",
      "spaceComplexity": "O(1) for iterative, O(log n) for recursive"
    },
    "examples": [
      {
        "input": [
          [
            1,
            3,
            5,
            7,
            9
          ],
          5
        ],
        "output": 2,
        "description": "Middle"
      },
      {
        "input": [
          [
            1,
            2,
            3
          ],
          4
        ],
        "output": -1,
        "description": "Not found"
      },
      {
        "input": [
          [],
          5
        ],
        "output": -1,
        "description": "Empty"
      },
      {
        "input": [
          [
            1
          ],
          1
        ],
        "output": 0,
        "description": "Single found"
      },
      {
        "input": [
          [
            1
          ],
          2
        ],
        "output": -1,
        "description": "Single not found"
      },
      {
        "input": [
          [
            1,
            2,
            2,
            3
          ],
          2
        ],
        "output": 1,
        "description": "Duplicates"
      }
    ],
    "code": "import { ExerciseMetadata, ExampleCase } from '@interfaces/exercises';\n\n/**\n * Binary Search Exercise Implementation\n * \n * DESCRIPTION:\n * Finds target index in sorted array (-1 if not found).\n * \n * EXAMPLE:\n * [1, 3, 5, 7, 9], 5 → 2\n * \n * CONCEPTS:\n * - Divide-and-conquer\n * - Logarithmic search\n * \n * PERFORMANCE:\n * - Time: O(log n)\n * - Space: O(1) iterative, O(log n) recursive\n * \n * Multiple implementations included to show different approaches.\n */\n\nexport function binarySearch(arr: number[], target: number): number {\n  if (!Array.isArray(arr) || !arr.every(Number.isFinite)) throw new Error(\"Input must be a sorted array of numbers\");\n  if (typeof target !== 'number' || !Number.isFinite(target)) throw new Error(\"Target must be a finite number\");\n  let low = 0;\n  let high = arr.length - 1;\n  while (low <= high) {\n    const mid = low + Math.floor((high - low) / 2);\n    if (arr[mid] === target) return mid;\n    else if (arr[mid] < target) low = mid + 1;\n    else high = mid - 1;\n  }\n  return -1;\n}\n\nexport function binarySearchRecursive(arr: number[], target: number, low = 0, high = arr.length - 1): number {\n  if (!Array.isArray(arr) || !arr.every(Number.isFinite)) throw new Error(\"Input must be a sorted array of numbers\");\n  if (typeof target !== 'number' || !Number.isFinite(target)) throw new Error(\"Target must be a finite number\");\n  if (low > high) return -1;\n  const mid = low + Math.floor((high - low) / 2);\n  if (arr[mid] === target) return mid;\n  if (arr[mid] < target) return binarySearchRecursive(arr, target, mid + 1, high);\n  return binarySearchRecursive(arr, target, low, mid - 1);\n}\n\nexport const metadata: ExerciseMetadata = {\n  title: \"Binary Search\",\n  description: \"Finds the index of a target in a sorted array\",\n  concepts: [\"divide-and-conquer\", \"logarithmic search\"],\n  timeComplexity: \"O(log n)\",\n  spaceComplexity: \"O(1) for iterative, O(log n) for recursive\"\n};\n\nexport const examples: ExampleCase[] = [\n  { input: [[1, 3, 5, 7, 9], 5], output: 2, description: \"Middle\" },\n  { input: [[1, 2, 3], 4], output: -1, description: \"Not found\" },\n  { input: [[], 5], output: -1, description: \"Empty\" },\n  { input: [[1], 1], output: 0, description: \"Single found\" },\n  { input: [[1], 2], output: -1, description: \"Single not found\" },\n  { input: [[1, 2, 2, 3], 2], output: 1, description: \"Duplicates\" }\n];\n\nexport default { binarySearch, binarySearchRecursive, metadata, examples };",
    "functions": [
      "binarySearch",
      "binarySearchRecursive"
    ]
  },
  {
    "name": "FactorialCalc",
    "slug": "factorial-calc",
    "metadata": {
      "title": "Factorial Calculator",
      "description": "Computes the factorial of a non-negative integer",
      "concepts": [
        "recursion",
        "iteration",
        "input validation",
        "mathematics"
      ],
      "timeComplexity": "O(n)",
      "spaceComplexity": "O(n) for recursive, O(1) for iterative"
    },
    "examples": [
      {
        "input": 5,
        "output": 120,
        "description": "Factorial of 5"
      },
      {
        "input": 0,
        "output": 1,
        "description": "Factorial of 0"
      },
      {
        "input": 1,
        "output": 1,
        "description": "Factorial of 1"
      },
      {
        "input": 3,
        "output": 6,
        "description": "Factorial of 3"
      },
      {
        "input": -1,
        "output": {},
        "description": "Negative error"
      },
      {
        "input": 2.5,
        "output": {},
        "description": "Non-integer error"
      }
    ],
    "code": "import { ExerciseMetadata, ExampleCase } from '@interfaces/exercises';\n\n/**\n * Factorial Calculator Exercise Implementation\n * \n * DESCRIPTION:\n * Computes factorial of a non-negative integer.\n * \n * EXAMPLE:\n * 5 → 120\n * \n * CONCEPTS:\n * - Recursion or iteration\n * - Validation\n * \n * PERFORMANCE:\n * - Time: O(n)\n * - Space: O(n) recursive, O(1) iterative\n * \n * Multiple implementations included to show different approaches.\n */\n\nexport function factorial(n: number): number {\n  if (!Number.isInteger(n)) throw new Error(\"Input must be an integer\");\n  if (n < 0) throw new Error(\"Factorial is not defined for negative numbers\");\n  if (n === 0 || n === 1) return 1;\n  return n * factorial(n - 1);\n}\n\nexport function factorialIterative(n: number): number {\n  if (!Number.isInteger(n)) throw new Error(\"Input must be an integer\");\n  if (n < 0) throw new Error(\"Factorial is not defined for negative numbers\");\n  let result = 1;\n  for (let i = 2; i <= n; i++) result *= i;\n  return result;\n}\n\nexport const metadata: ExerciseMetadata = {\n  title: \"Factorial Calculator\",\n  description: \"Computes the factorial of a non-negative integer\",\n  concepts: [\"recursion\", \"iteration\", \"input validation\", \"mathematics\"],\n  timeComplexity: \"O(n)\",\n  spaceComplexity: \"O(n) for recursive, O(1) for iterative\"\n};\n\nexport const examples: ExampleCase[] = [\n  { input: 5, output: 120, description: \"Factorial of 5\" },\n  { input: 0, output: 1, description: \"Factorial of 0\" },\n  { input: 1, output: 1, description: \"Factorial of 1\" },\n  { input: 3, output: 6, description: \"Factorial of 3\" },\n  { input: -1, output: new Error(\"Factorial is not defined for negative numbers\"), description: \"Negative error\" },\n  { input: 2.5, output: new Error(\"Input must be an integer\"), description: \"Non-integer error\" }\n];\n\nexport default { factorial, factorialIterative, metadata, examples };",
    "functions": [
      "factorial",
      "factorialIterative"
    ]
  },
  {
    "name": "FibonacciSeq",
    "slug": "fibonacci-seq",
    "metadata": {
      "title": "Fibonacci Sequence",
      "description": "Generates the first n numbers in the Fibonacci sequence",
      "concepts": [
        "iteration",
        "recursion",
        "memoization",
        "array manipulation"
      ],
      "timeComplexity": "O(n) for iterative/memoized",
      "spaceComplexity": "O(n)"
    },
    "examples": [
      {
        "input": 7,
        "output": [
          0,
          1,
          1,
          2,
          3,
          5,
          8
        ],
        "description": "n=7"
      },
      {
        "input": 0,
        "output": [],
        "description": "n=0"
      },
      {
        "input": 1,
        "output": [
          0
        ],
        "description": "n=1"
      },
      {
        "input": 2,
        "output": [
          0,
          1
        ],
        "description": "n=2"
      },
      {
        "input": -1,
        "output": {},
        "description": "Negative error"
      },
      {
        "input": 3.5,
        "output": {},
        "description": "Non-integer error"
      }
    ],
    "code": "import { ExerciseMetadata, ExampleCase } from '@interfaces/exercises';\n\n/**\n * Fibonacci Sequence Exercise Implementation\n * \n * DESCRIPTION:\n * Generates the first n numbers in the Fibonacci sequence.\n * \n * EXAMPLE:\n * 7 → [0, 1, 1, 2, 3, 5, 8]\n * \n * CONCEPTS:\n * - Iteration or recursion\n * - Memoization\n * \n * PERFORMANCE:\n * - Time: O(n)\n * - Space: O(n)\n * \n * Multiple implementations included to show different approaches.\n */\n\nexport function FibonacciSeq(count: number): number[] {\n  if (!Number.isInteger(count)) throw new Error(\"Input must be an integer\");\n  if (count < 0) throw new Error(\"Input must be non-negative\");\n  if (count === 0) return [];\n  if (count === 1) return [0];\n  if (count === 2) return [0, 1];\n\n  const fibSeq: number[] = [0, 1];\n  for (let i = 2; i < count; i++) fibSeq[i] = fibSeq[i - 1] + fibSeq[i - 2];\n  return fibSeq;\n}\n\nexport function FibonacciSeqMemoized(count: number): number[] {\n  if (!Number.isInteger(count)) throw new Error(\"Input must be an integer\");\n  if (count < 0) throw new Error(\"Input must be non-negative\");\n  if (count === 0) return [];\n\n  const memo: { [key: number]: number } = { 0: 0, 1: 1 };\n  const fib = (n: number): number => {\n    if (n in memo) return memo[n];\n    memo[n] = fib(n - 1) + fib(n - 2);\n    return memo[n];\n  };\n  \n  const result: number[] = [];\n  for (let i = 0; i < count; i++) result.push(fib(i));\n  return result;\n}\n\nexport const metadata: ExerciseMetadata = {\n  title: \"Fibonacci Sequence\",\n  description: \"Generates the first n numbers in the Fibonacci sequence\",\n  concepts: [\"iteration\", \"recursion\", \"memoization\", \"array manipulation\"],\n  timeComplexity: \"O(n) for iterative/memoized\",\n  spaceComplexity: \"O(n)\"\n};\n\nexport const examples: ExampleCase[] = [\n  { input: 7, output: [0, 1, 1, 2, 3, 5, 8], description: \"n=7\" },\n  { input: 0, output: [], description: \"n=0\" },\n  { input: 1, output: [0], description: \"n=1\" },\n  { input: 2, output: [0, 1], description: \"n=2\" },\n  { input: -1, output: new Error(\"Input must be non-negative\"), description: \"Negative error\" },\n  { input: 3.5, output: new Error(\"Input must be an integer\"), description: \"Non-integer error\" }\n];\n\nexport default { FibonacciSeq, FibonacciSeqMemoized, metadata, examples };",
    "functions": [
      "FibonacciSeq",
      "FibonacciSeqMemoized"
    ]
  },
  {
    "name": "FizzBuzz",
    "slug": "fizz-buzz",
    "metadata": {
      "title": "FizzBuzz",
      "description": "Count from 1 to n, replacing multiples of 3 with 'Fizz', 5 with 'Buzz', both with 'FizzBuzz'",
      "concepts": [
        "loops",
        "conditionals",
        "modulo operator",
        "string manipulation"
      ],
      "timeComplexity": "O(n)",
      "spaceComplexity": "O(n)"
    },
    "examples": [
      {
        "input": 15,
        "output": [
          "1",
          "2",
          "Fizz",
          "4",
          "Buzz",
          "Fizz",
          "7",
          "8",
          "Fizz",
          "Buzz",
          "11",
          "Fizz",
          "13",
          "14",
          "FizzBuzz"
        ],
        "description": "Classic FizzBuzz up to 15"
      },
      {
        "input": 5,
        "output": [
          "1",
          "2",
          "Fizz",
          "4",
          "Buzz"
        ],
        "description": "Small example"
      },
      {
        "input": 0,
        "output": {},
        "description": "Invalid input"
      }
    ],
    "code": "import { ExerciseMetadata, ExampleCase } from '@interfaces/exercises';\n\n/**\n * FizzBuzz Exercise Implementation\n * \n * DESCRIPTION:\n * Count from 1 to n, replacing multiples of 3 with \"Fizz\", 5 with \"Buzz\", both with \"FizzBuzz\".\n * \n * EXAMPLE (n=15):\n * [\"1\", \"2\", \"Fizz\", \"4\", \"Buzz\", \"Fizz\", \"7\", \"8\", \"Fizz\", \"Buzz\", \"11\", \"Fizz\", \"13\", \"14\", \"FizzBuzz\"]\n * \n * CONCEPTS:\n * - Loops and conditionals\n * - Modulo operator\n * \n * PERFORMANCE:\n * - Time: O(n)\n * - Space: O(n)\n * \n * Multiple implementations included to show different approaches.\n */\n\nexport function fizzBuzz(n: number): string[] {\n  if (!Number.isInteger(n) || n < 1) throw new Error(\"Input must be a positive integer\");\n  const result: string[] = [];\n  for (let i = 1; i <= n; i++) {\n    if (i % 15 === 0) result.push(\"FizzBuzz\");\n    else if (i % 3 === 0) result.push(\"Fizz\");\n    else if (i % 5 === 0) result.push(\"Buzz\");\n    else result.push(i.toString());\n  }\n  return result;\n}\n\nexport function fizzBuzzConcat(n: number): string[] {\n  if (!Number.isInteger(n) || n < 1) throw new Error(\"Input must be a positive integer\");\n  const result: string[] = [];\n  for (let i = 1; i <= n; i++) {\n    let output = \"\";\n    if (i % 3 === 0) output += \"Fizz\";\n    if (i % 5 === 0) output += \"Buzz\";\n    result.push(output || i.toString());\n  }\n  return result;\n}\n\nexport const fizzBuzzOneLiner = (n: number): string[] => {\n  if (!Number.isInteger(n) || n < 1) throw new Error(\"Input must be a positive integer\");\n  return Array.from({ length: n }, (_, i) => {\n    const num = i + 1;\n    return (num % 3 === 0 ? \"Fizz\" : \"\") + (num % 5 === 0 ? \"Buzz\" : \"\") || num.toString();\n  });\n};\n\nexport const metadata: ExerciseMetadata = {\n  title: \"FizzBuzz\",\n  description: \"Count from 1 to n, replacing multiples of 3 with 'Fizz', 5 with 'Buzz', both with 'FizzBuzz'\",\n  concepts: [\"loops\", \"conditionals\", \"modulo operator\", \"string manipulation\"],\n  timeComplexity: \"O(n)\",\n  spaceComplexity: \"O(n)\"\n};\n\nexport const examples: ExampleCase[] = [\n  { input: 15, output: [\"1\", \"2\", \"Fizz\", \"4\", \"Buzz\", \"Fizz\", \"7\", \"8\", \"Fizz\", \"Buzz\", \"11\", \"Fizz\", \"13\", \"14\", \"FizzBuzz\"], description: \"Classic FizzBuzz up to 15\" },\n  { input: 5, output: [\"1\", \"2\", \"Fizz\", \"4\", \"Buzz\"], description: \"Small example\" },\n  { input: 0, output: new Error(\"Input must be a positive integer\"), description: \"Invalid input\" }\n];\n\nexport default { fizzBuzz, fizzBuzzConcat, fizzBuzzOneLiner, metadata, examples };",
    "functions": [
      "fizzBuzzOneLiner",
      "fizzBuzz",
      "fizzBuzzConcat"
    ]
  },
  {
    "name": "LRUCache",
    "slug": "l-r-u-cache",
    "metadata": {
      "title": "LRU Cache",
      "description": "Implements a Least Recently Used (LRU) cache with get and put",
      "concepts": [
        "hash maps",
        "doubly linked lists"
      ],
      "timeComplexity": "O(1) for get/put",
      "spaceComplexity": "O(capacity)"
    },
    "examples": [
      {
        "input": {
          "operations": [
            [
              "LRUCache",
              2
            ],
            [
              "put",
              1,
              1
            ],
            [
              "put",
              2,
              2
            ],
            [
              "get",
              1
            ],
            [
              "put",
              3,
              3
            ],
            [
              "get",
              2
            ],
            [
              "put",
              4,
              4
            ],
            [
              "get",
              1
            ],
            [
              "get",
              3
            ],
            [
              "get",
              4
            ]
          ]
        },
        "output": [
          null,
          null,
          null,
          1,
          null,
          -1,
          null,
          -1,
          3,
          4
        ],
        "description": "Standard LRU operations with evictions"
      },
      {
        "input": {
          "operations": [
            [
              "LRUCache",
              1
            ],
            [
              "put",
              1,
              1
            ],
            [
              "get",
              1
            ],
            [
              "put",
              2,
              2
            ],
            [
              "get",
              1
            ]
          ]
        },
        "output": [
          null,
          null,
          1,
          null,
          -1
        ],
        "description": "Capacity 1, eviction on second put"
      },
      {
        "input": {
          "operations": [
            [
              "LRUCache",
              0
            ]
          ]
        },
        "output": {},
        "description": "Invalid capacity"
      },
      {
        "input": {
          "operations": [
            [
              "LRUCache",
              2
            ],
            [
              "put",
              1,
              1
            ],
            [
              "get",
              2
            ]
          ]
        },
        "output": [
          null,
          null,
          -1
        ],
        "description": "Get missing key"
      }
    ],
    "code": "import { ExerciseMetadata, ExampleCase } from '@interfaces/exercises';\n\n/**\n * LRU Cache Exercise Implementation\n * \n * DESCRIPTION:\n * Implements a Least Recently Used (LRU) cache with get and put operations.\n * Evicts least recent item when capacity exceeded.\n * \n * EXAMPLE:\n * cache = new LRUCache(2); cache.put(1,1); cache.put(2,2); cache.get(1) → 1; cache.put(3,3); cache.get(2) → -1\n * \n * CONCEPTS:\n * - Hash maps\n * - Doubly linked lists for order\n * \n * PERFORMANCE:\n * - Time: O(1) for get/put\n * - Space: O(capacity)\n * \n * Multiple implementations included to show different approaches.\n */\n\n// Main class (Map-based)\nexport class LRUCache {\n  private capacity: number;\n  private cache: Map<number, number>;\n\n  constructor(capacity: number) {\n    if (!Number.isInteger(capacity) || capacity <= 0) {\n      throw new Error(\"Capacity must be a positive integer\");\n    }\n    this.capacity = capacity;\n    this.cache = new Map();\n  }\n\n  get(key: number): number {\n    if (typeof key !== 'number') {\n      throw new Error(\"Key must be a number\");\n    }\n    if (!this.cache.has(key)) {\n      return -1;\n    }\n    const value = this.cache.get(key)!;\n    this.cache.delete(key);\n    this.cache.set(key, value);\n    return value;\n  }\n\n  put(key: number, value: number): void {\n    if (typeof key !== 'number' || typeof value !== 'number') {\n      throw new Error(\"Key and value must be numbers\");\n    }\n    if (this.cache.has(key)) {\n      this.cache.delete(key);\n    }\n    this.cache.set(key, value);\n    if (this.cache.size > this.capacity) {\n      const lruKey = this.cache.keys().next().value;\n      if (lruKey !== undefined) {\n        this.cache.delete(lruKey);\n      }\n    }\n  }\n}\n\n// Alternative class (Map + DLL for strict O(1))\nclass ListNode {\n  key: number;\n  value: number;\n  prev: ListNode | null = null;\n  next: ListNode | null = null;\n\n  constructor(key = 0, value = 0) {\n    this.key = key;\n    this.value = value;\n  }\n}\n\nexport class LRUCacheDLL {\n  private capacity: number;\n  private cache: Map<number, ListNode>;\n  private head: ListNode;\n  private tail: ListNode;\n\n  constructor(capacity: number) {\n    if (!Number.isInteger(capacity) || capacity <= 0) {\n      throw new Error(\"Capacity must be a positive integer\");\n    }\n    this.capacity = capacity;\n    this.cache = new Map();\n    this.head = new ListNode();\n    this.tail = new ListNode();\n    this.head.next = this.tail;\n    this.tail.prev = this.head;\n  }\n\n  get(key: number): number {\n    if (typeof key !== 'number') {\n      throw new Error(\"Key must be a number\");\n    }\n    if (!this.cache.has(key)) return -1;\n    const node = this.cache.get(key)!;\n    this.moveToTail(node);\n    return node.value;\n  }\n\n  put(key: number, value: number): void {\n    if (typeof key !== 'number' || typeof value !== 'number') {\n      throw new Error(\"Key and value must be numbers\");\n    }\n    if (this.cache.has(key)) {\n      const node = this.cache.get(key)!;\n      node.value = value;\n      this.moveToTail(node);\n      return;\n    }\n    const node = new ListNode(key, value);\n    this.cache.set(key, node);\n    this.addToTail(node);\n    if (this.cache.size > this.capacity) {\n      const lru = this.head.next!;\n      this.removeNode(lru);\n      this.cache.delete(lru.key);\n    }\n  }\n\n  private addToTail(node: ListNode): void {\n    node.prev = this.tail.prev;\n    node.next = this.tail;\n    this.tail.prev!.next = node;\n    this.tail.prev = node;\n  }\n\n  private removeNode(node: ListNode): void {\n    node.prev!.next = node.next;\n    node.next!.prev = node.prev;\n  }\n\n  private moveToTail(node: ListNode): void {\n    this.removeNode(node);\n    this.addToTail(node);\n  }\n}\n\n// Exercise metadata\nexport const metadata: ExerciseMetadata = {\n  title: \"LRU Cache\",\n  description: \"Implements a Least Recently Used (LRU) cache with get and put\",\n  concepts: [\"hash maps\", \"doubly linked lists\"],\n  timeComplexity: \"O(1) for get/put\",\n  spaceComplexity: \"O(capacity)\"\n};\n\n// Example test cases\nexport const examples: ExampleCase[] = [\n  {\n    input: {\n      operations: [\n        [\"LRUCache\", 2],\n        [\"put\", 1, 1],\n        [\"put\", 2, 2],\n        [\"get\", 1],\n        [\"put\", 3, 3],\n        [\"get\", 2],\n        [\"put\", 4, 4],\n        [\"get\", 1],\n        [\"get\", 3],\n        [\"get\", 4]\n      ]\n    },\n    output: [null, null, null, 1, null, -1, null, -1, 3, 4],\n    description: \"Standard LRU operations with evictions\"\n  },\n  {\n    input: {\n      operations: [\n        [\"LRUCache\", 1],\n        [\"put\", 1, 1],\n        [\"get\", 1],\n        [\"put\", 2, 2],\n        [\"get\", 1]\n      ]\n    },\n    output: [null, null, 1, null, -1],\n    description: \"Capacity 1, eviction on second put\"\n  },\n  {\n    input: {\n      operations: [\n        [\"LRUCache\", 0]\n      ]\n    },\n    output: new Error(\"Capacity must be a positive integer\"),\n    description: \"Invalid capacity\"\n  },\n  {\n    input: {\n      operations: [\n        [\"LRUCache\", 2],\n        [\"put\", 1, 1],\n        [\"get\", 2]\n      ]\n    },\n    output: [null, null, -1],\n    description: \"Get missing key\"\n  }\n];\n\n// Default export for easy importing\nexport default {\n  LRUCache,\n  LRUCacheDLL,\n  metadata,\n  examples\n};",
    "functions": [
      "LRUCache",
      "LRUCacheDLL"
    ]
  },
  {
    "name": "LongestCommonSubstring",
    "slug": "longest-common-substring",
    "metadata": {
      "title": "Longest Common Substring",
      "description": "Finds the longest substring common to two strings",
      "concepts": [
        "dynamic programming",
        "string manipulation"
      ],
      "timeComplexity": "O(m*n) for DP, O(m*n*min(m,n)) for brute force",
      "spaceComplexity": "O(m*n) for DP, O(1) for brute force"
    },
    "examples": [
      {
        "input": [
          "ABCD",
          "ACDF"
        ],
        "output": "CD",
        "description": "Basic"
      },
      {
        "input": [
          "hello",
          "world"
        ],
        "output": "l",
        "description": "Single char"
      },
      {
        "input": [
          "abcde",
          "fghij"
        ],
        "output": "",
        "description": "No common"
      },
      {
        "input": [
          "",
          ""
        ],
        "output": "",
        "description": "Empty"
      },
      {
        "input": [
          "a",
          "a"
        ],
        "output": "a",
        "description": "Identical single"
      },
      {
        "input": [
          "banana",
          "anana"
        ],
        "output": "anana",
        "description": "Overlapping"
      }
    ],
    "code": "import { ExerciseMetadata, ExampleCase } from '@interfaces/exercises';\n\n/**\n * Longest Common Substring Exercise Implementation\n * \n * DESCRIPTION:\n * Finds the longest substring common to two strings.\n * \n * EXAMPLE:\n * \"ABCD\", \"ACDF\" → \"CD\"\n * \n * CONCEPTS:\n * - Dynamic programming\n * - String manipulation\n * \n * PERFORMANCE:\n * - Time: O(m*n) DP, O(m*n*min(m,n)) brute\n * - Space: O(m*n) DP, O(1) brute\n * \n * Multiple implementations included to show different approaches.\n */\n\nexport function longestCommonSubstring(str1: string, str2: string): string {\n  if (typeof str1 !== 'string' || typeof str2 !== 'string') throw new Error(\"Inputs must be strings\");\n  const m = str1.length;\n  const n = str2.length;\n  let maxLength = 0;\n  let endIndex = 0;\n  const dp: number[][] = Array.from({ length: m + 1 }, () => Array(n + 1).fill(0));\n  for (let i = 1; i <= m; i++) {\n    for (let j = 1; j <= n; j++) {\n      if (str1[i - 1] === str2[j - 1]) {\n        dp[i][j] = dp[i - 1][j - 1] + 1;\n        if (dp[i][j] > maxLength) {\n          maxLength = dp[i][j];\n          endIndex = i;\n        }\n      } else {\n        dp[i][j] = 0;\n      }\n    }\n  }\n  return str1.substring(endIndex - maxLength, endIndex);\n}\n\nexport function longestCommonSubstringBrute(str1: string, str2: string): string {\n  if (typeof str1 !== 'string' || typeof str2 !== 'string') throw new Error(\"Inputs must be strings\");\n  let maxLength = 0;\n  let longest = '';\n  for (let i = 0; i < str1.length; i++) {\n    for (let j = 0; j < str2.length; j++) {\n      let k = 0;\n      while (i + k < str1.length && j + k < str2.length && str1[i + k] === str2[j + k]) k++;\n      if (k > maxLength) {\n        maxLength = k;\n        longest = str1.substring(i, i + k);\n      }\n    }\n  }\n  return longest;\n}\n\nexport const metadata: ExerciseMetadata = {\n  title: \"Longest Common Substring\",\n  description: \"Finds the longest substring common to two strings\",\n  concepts: [\"dynamic programming\", \"string manipulation\"],\n  timeComplexity: \"O(m*n) for DP, O(m*n*min(m,n)) for brute force\",\n  spaceComplexity: \"O(m*n) for DP, O(1) for brute force\"\n};\n\nexport const examples: ExampleCase[] = [\n  { input: [\"ABCD\", \"ACDF\"], output: \"CD\", description: \"Basic\" },\n  { input: [\"hello\", \"world\"], output: \"l\", description: \"Single char\" },\n  { input: [\"abcde\", \"fghij\"], output: \"\", description: \"No common\" },\n  { input: [\"\", \"\"], output: \"\", description: \"Empty\" },\n  { input: [\"a\", \"a\"], output: \"a\", description: \"Identical single\" },\n  { input: [\"banana\", \"anana\"], output: \"anana\", description: \"Overlapping\" }\n];\n\nexport default { longestCommonSubstring, longestCommonSubstringBrute, metadata, examples };",
    "functions": [
      "longestCommonSubstring",
      "longestCommonSubstringBrute"
    ]
  },
  {
    "name": "MergeSort",
    "slug": "merge-sort",
    "metadata": {
      "title": "Merge Sort",
      "description": "Sorts an array using merge sort",
      "concepts": [
        "recursion",
        "divide-and-conquer"
      ],
      "timeComplexity": "O(n log n)",
      "spaceComplexity": "O(n)"
    },
    "examples": [
      {
        "input": [
          5,
          2,
          8,
          1
        ],
        "output": [
          1,
          2,
          5,
          8
        ],
        "description": "Unsorted array"
      },
      {
        "input": [],
        "output": [],
        "description": "Empty array"
      },
      {
        "input": [
          1
        ],
        "output": [
          1
        ],
        "description": "Single element"
      },
      {
        "input": [
          3,
          1,
          4,
          1,
          5,
          9,
          2,
          6
        ],
        "output": [
          1,
          1,
          2,
          3,
          4,
          5,
          6,
          9
        ],
        "description": "With duplicates"
      },
      {
        "input": [
          1,
          2,
          3,
          4
        ],
        "output": [
          1,
          2,
          3,
          4
        ],
        "description": "Already sorted"
      },
      {
        "input": [
          4,
          3,
          2,
          1
        ],
        "output": [
          1,
          2,
          3,
          4
        ],
        "description": "Reverse sorted"
      }
    ],
    "code": "import { ExerciseMetadata, ExampleCase } from '@interfaces/exercises';\n\n/**\n * Merge Sort Exercise Implementation\n * \n * DESCRIPTION:\n * Sorts an array using merge sort.\n * \n * EXAMPLE:\n * [5, 2, 8, 1] → [1, 2, 5, 8]\n * \n * CONCEPTS:\n * - Recursion\n * - Divide-and-conquer\n * \n * PERFORMANCE:\n * - Time: O(n log n)\n * - Space: O(n)\n * \n * Multiple implementations included to show different approaches.\n */\n\nexport function mergeSort(arr: number[]): number[] {\n  if (!Array.isArray(arr) || !arr.every(Number.isFinite)) throw new Error(\"Input must be an array of finite numbers\");\n  if (arr.length <= 1) return arr.slice();\n\n  const mid = Math.floor(arr.length / 2);\n  const left = mergeSort(arr.slice(0, mid));\n  const right = mergeSort(arr.slice(mid));\n\n  return merge(left, right);\n}\n\nfunction merge(left: number[], right: number[]): number[] {\n  const merged: number[] = [];\n  let i = 0;\n  let j = 0;\n\n  while (i < left.length && j < right.length) {\n    if (left[i] < right[j]) merged.push(left[i++]);\n    else merged.push(right[j++]);\n  }\n\n  return merged.concat(left.slice(i)).concat(right.slice(j));\n}\n\nexport function mergeSortIterative(arr: number[]): number[] {\n  if (!Array.isArray(arr) || !arr.every(Number.isFinite)) throw new Error(\"Input must be an array of finite numbers\");\n  if (arr.length <= 1) return arr.slice();\n\n  const workArr = arr.slice();\n  let width = 1;\n  while (width < arr.length) {\n    for (let i = 0; i < arr.length; i += 2 * width) {\n      const left = workArr.slice(i, i + width);\n      const right = workArr.slice(i + width, i + 2 * width);\n      const merged = merge(left, right);\n      workArr.splice(i, merged.length, ...merged);\n    }\n    width *= 2;\n  }\n  return workArr;\n}\n\nexport const metadata: ExerciseMetadata = {\n  title: \"Merge Sort\",\n  description: \"Sorts an array using merge sort\",\n  concepts: [\"recursion\", \"divide-and-conquer\"],\n  timeComplexity: \"O(n log n)\",\n  spaceComplexity: \"O(n)\"\n};\n\nexport const examples: ExampleCase[] = [\n  { input: [5, 2, 8, 1], output: [1, 2, 5, 8], description: \"Unsorted array\" },\n  { input: [], output: [], description: \"Empty array\" },\n  { input: [1], output: [1], description: \"Single element\" },\n  { input: [3, 1, 4, 1, 5, 9, 2, 6], output: [1, 1, 2, 3, 4, 5, 6, 9], description: \"With duplicates\" },\n  { input: [1, 2, 3, 4], output: [1, 2, 3, 4], description: \"Already sorted\" },\n  { input: [4, 3, 2, 1], output: [1, 2, 3, 4], description: \"Reverse sorted\" }\n];\n\nexport default { mergeSort, mergeSortIterative, metadata, examples };",
    "functions": [
      "mergeSort",
      "mergeSortIterative"
    ]
  },
  {
    "name": "Palindrome",
    "slug": "palindrome",
    "metadata": {
      "title": "Palindrome Checker",
      "description": "Checks if a string is a palindrome, ignoring case, spaces, and non-alphanumeric characters",
      "concepts": [
        "string manipulation",
        "regular expressions",
        "comparison"
      ],
      "timeComplexity": "O(n)",
      "spaceComplexity": "O(n)"
    },
    "examples": [
      {
        "input": "A man, a plan, a canal: Panama",
        "output": true,
        "description": "Classic palindrome with spaces and punctuation"
      },
      {
        "input": "race a car",
        "output": false,
        "description": "Non-palindrome with spaces"
      },
      {
        "input": "Was it a car or a cat I saw?",
        "output": true,
        "description": "Palindrome with spaces, punctuation, and mixed case"
      },
      {
        "input": "",
        "output": true,
        "description": "Empty string"
      },
      {
        "input": "a",
        "output": true,
        "description": "Single character"
      },
      {
        "input": ".,",
        "output": true,
        "description": "Only punctuation"
      }
    ],
    "code": "import { ExerciseMetadata, ExampleCase } from '@interfaces/exercises';\n\n/**\n * Palindrome Checker Exercise Implementation\n * \n * DESCRIPTION:\n * Checks if a string is a palindrome, ignoring case, spaces, and non-alphanumeric characters.\n * \n * EXAMPLE:\n * \"A man, a plan, a canal: Panama\" → true\n * \n * CONCEPTS:\n * - String manipulation\n * - Regular expressions\n * \n * PERFORMANCE:\n * - Time: O(n)\n * - Space: O(n)\n * \n * Multiple implementations included to show different approaches.\n */\n\nexport function isPalindrome(str: string): boolean {\n  if (typeof str !== 'string') throw new Error(\"Input must be a string\");\n  const cleaned = str.toLowerCase().replace(/[^a-z0-9]/g, '');\n  return cleaned === cleaned.split('').reverse().join('');\n}\n\nexport function isPalindromeTwoPointer(str: string): boolean {\n  if (typeof str !== 'string') throw new Error(\"Input must be a string\");\n  const cleaned = str.toLowerCase().replace(/[^a-z0-9]/g, '');\n  let left = 0;\n  let right = cleaned.length - 1;\n  while (left < right) {\n    if (cleaned[left] !== cleaned[right]) return false;\n    left++;\n    right--;\n  }\n  return true;\n}\n\nexport const metadata: ExerciseMetadata = {\n  title: \"Palindrome Checker\",\n  description: \"Checks if a string is a palindrome, ignoring case, spaces, and non-alphanumeric characters\",\n  concepts: [\"string manipulation\", \"regular expressions\", \"comparison\"],\n  timeComplexity: \"O(n)\",\n  spaceComplexity: \"O(n)\"\n};\n\nexport const examples: ExampleCase[] = [\n  { input: \"A man, a plan, a canal: Panama\", output: true, description: \"Classic palindrome with spaces and punctuation\" },\n  { input: \"race a car\", output: false, description: \"Non-palindrome with spaces\" },\n  { input: \"Was it a car or a cat I saw?\", output: true, description: \"Palindrome with spaces, punctuation, and mixed case\" },\n  { input: \"\", output: true, description: \"Empty string\" },\n  { input: \"a\", output: true, description: \"Single character\" },\n  { input: \".,\", output: true, description: \"Only punctuation\" }\n];\n\nexport default { isPalindrome, isPalindromeTwoPointer, metadata, examples };",
    "functions": [
      "isPalindrome",
      "isPalindromeTwoPointer"
    ]
  },
  {
    "name": "ReverseString",
    "slug": "reverse-string",
    "metadata": {
      "title": "Reverse a String",
      "description": "Reverses a string, returning the characters in opposite order",
      "concepts": [
        "string manipulation",
        "array iteration",
        "built-in methods"
      ],
      "timeComplexity": "O(n)",
      "spaceComplexity": "O(n)"
    },
    "examples": [
      {
        "input": "hello",
        "output": "olleh",
        "description": "Basic reversal"
      },
      {
        "input": "",
        "output": "",
        "description": "Empty string"
      },
      {
        "input": "a",
        "output": "a",
        "description": "Single character"
      },
      {
        "input": "12345",
        "output": "54321",
        "description": "Numeric string"
      },
      {
        "input": "!@#",
        "output": "#@!",
        "description": "Special characters"
      },
      {
        "input": "Hello World",
        "output": "dlroW olleH",
        "description": "With spaces"
      }
    ],
    "code": "import { ExerciseMetadata, ExampleCase } from '@interfaces/exercises';\n\n/**\n * Reverse a String Exercise Implementation\n * \n * DESCRIPTION:\n * Reverses a string.\n * \n * EXAMPLE:\n * \"hello\" → \"olleh\"\n * \n * CONCEPTS:\n * - String manipulation\n * - Iteration\n * \n * PERFORMANCE:\n * - Time: O(n)\n * - Space: O(n)\n * \n * Multiple implementations included to show different approaches.\n */\n\nexport function reverseString(str: string): string {\n  if (typeof str !== 'string') throw new Error(\"Input must be a string\");\n  return str.split('').reverse().join('');\n}\n\nexport function reverseStringManual(str: string): string {\n  if (typeof str !== 'string') throw new Error(\"Input must be a string\");\n  let result = '';\n  for (let i = str.length - 1; i >= 0; i--) result += str[i];\n  return result;\n}\n\nexport const metadata: ExerciseMetadata = {\n  title: \"Reverse a String\",\n  description: \"Reverses a string, returning the characters in opposite order\",\n  concepts: [\"string manipulation\", \"array iteration\", \"built-in methods\"],\n  timeComplexity: \"O(n)\",\n  spaceComplexity: \"O(n)\"\n};\n\nexport const examples: ExampleCase[] = [\n  { input: \"hello\", output: \"olleh\", description: \"Basic reversal\" },\n  { input: \"\", output: \"\", description: \"Empty string\" },\n  { input: \"a\", output: \"a\", description: \"Single character\" },\n  { input: \"12345\", output: \"54321\", description: \"Numeric string\" },\n  { input: \"!@#\", output: \"#@!\", description: \"Special characters\" },\n  { input: \"Hello World\", output: \"dlroW olleH\", description: \"With spaces\" }\n];\n\nexport default { reverseString, reverseStringManual, metadata, examples };",
    "functions": [
      "reverseString",
      "reverseStringManual"
    ]
  },
  {
    "name": "SlidingWindowMax",
    "slug": "sliding-window-max",
    "metadata": {
      "title": "Sliding Window Maximum",
      "description": "Finds the maximum in each k-sized sliding window of an array",
      "concepts": [
        "sliding window",
        "deque",
        "brute-force"
      ],
      "timeComplexity": "O(n) for deque, O(n*k) for brute force",
      "spaceComplexity": "O(n)"
    },
    "examples": [
      {
        "input": [
          [
            1,
            3,
            -1,
            -3,
            5,
            3,
            6,
            7
          ],
          3
        ],
        "output": [
          3,
          3,
          5,
          5,
          6,
          7
        ],
        "description": "Standard sliding window"
      },
      {
        "input": [
          [
            1
          ],
          1
        ],
        "output": [
          1
        ],
        "description": "Single element window"
      },
      {
        "input": [
          [
            1,
            -1
          ],
          1
        ],
        "output": [
          1,
          -1
        ],
        "description": "Window size 1"
      },
      {
        "input": [
          [],
          3
        ],
        "output": [],
        "description": "Empty array"
      },
      {
        "input": [
          [
            9,
            8,
            7,
            6
          ],
          2
        ],
        "output": [
          9,
          8,
          7
        ],
        "description": "Decreasing array"
      },
      {
        "input": [
          [
            1,
            2,
            3,
            4
          ],
          5
        ],
        "output": [
          4
        ],
        "description": "k > length (adjusted to max)"
      }
    ],
    "code": "import { ExerciseMetadata, ExampleCase } from '@interfaces/exercises';\n\n/**\n * Sliding Window Maximum Exercise Implementation\n * \n * DESCRIPTION:\n * Finds the maximum in each k-sized sliding window of an array.\n * \n * EXAMPLE:\n * [1, 3, -1, -3, 5, 3, 6, 7], 3 → [3, 3, 5, 5, 6, 7]\n * \n * CONCEPTS:\n * - Sliding window\n * - Deque\n * \n * PERFORMANCE:\n * - Time: O(n) for deque, O(n*k) for brute force\n * - Space: O(n)\n * \n * Multiple implementations included to show different approaches.\n */\n\n// Main function (deque-based)\nexport function slidingWindowMax(nums: number[], k: number): number[] {\n  if (!Array.isArray(nums) || !nums.every(Number.isFinite)) throw new Error(\"Input must be an array of finite numbers\");\n  if (!Number.isInteger(k) || k <= 0) throw new Error(\"Window size must be a positive integer\");\n  if (nums.length === 0) return [];\n  if (k > nums.length) k = nums.length;\n\n  const result: number[] = [];\n  const deque: number[] = [];\n\n  for (let i = 0; i < nums.length; i++) {\n    if (deque.length && deque[0] < i - k + 1) deque.shift();\n    while (deque.length && nums[deque[deque.length - 1]] < nums[i]) deque.pop();\n    deque.push(i);\n    if (i >= k - 1) result.push(nums[deque[0]]);\n  }\n\n  return result;\n}\n\n// Alternative implementation (brute force)\nexport function slidingWindowMaxBrute(nums: number[], k: number): number[] {\n  if (!Array.isArray(nums) || !nums.every(Number.isFinite)) throw new Error(\"Input must be an array of finite numbers\");\n  if (!Number.isInteger(k) || k <= 0) throw new Error(\"Window size must be a positive integer\");\n  if (nums.length === 0) return [];\n  if (k > nums.length) k = nums.length;\n\n  const result: number[] = [];\n  for (let i = 0; i <= nums.length - k; i++) {\n    let max = nums[i];\n    for (let j = 1; j < k; j++) {\n      if (nums[i + j] > max) max = nums[i + j];\n    }\n    result.push(max);\n  }\n  return result;\n}\n\n// Exercise metadata\nexport const metadata: ExerciseMetadata = {\n  title: \"Sliding Window Maximum\",\n  description: \"Finds the maximum in each k-sized sliding window of an array\",\n  concepts: [\"sliding window\", \"deque\", \"brute-force\"],\n  timeComplexity: \"O(n) for deque, O(n*k) for brute force\",\n  spaceComplexity: \"O(n)\"\n};\n\n// Example test cases\nexport const examples: ExampleCase[] = [\n  {\n    input: [[1, 3, -1, -3, 5, 3, 6, 7], 3],\n    output: [3, 3, 5, 5, 6, 7],\n    description: \"Standard sliding window\"\n  },\n  {\n    input: [[1], 1],\n    output: [1],\n    description: \"Single element window\"\n  },\n  {\n    input: [[1, -1], 1],\n    output: [1, -1],\n    description: \"Window size 1\"\n  },\n  {\n    input: [[], 3],\n    output: [],\n    description: \"Empty array\"\n  },\n  {\n    input: [[9, 8, 7, 6], 2],\n    output: [9, 8, 7],\n    description: \"Decreasing array\"\n  },\n  {\n    input: [[1, 2, 3, 4], 5],\n    output: [4],\n    description: \"k > length (adjusted to max)\"\n  }\n];\n\n// Default export for easy importing\nexport default {\n  slidingWindowMax,\n  slidingWindowMaxBrute,\n  metadata,\n  examples\n};",
    "functions": [
      "slidingWindowMax",
      "slidingWindowMaxBrute"
    ]
  },
  {
    "name": "Trie",
    "slug": "trie",
    "metadata": {
      "title": "Trie-based Autocomplete",
      "description": "Trie for inserting words and suggesting completions for a prefix",
      "concepts": [
        "tree data structures",
        "DFS traversal"
      ],
      "timeComplexity": "O(k) insert/suggest",
      "spaceComplexity": "O(total chars)"
    },
    "examples": [
      {
        "input": {
          "operations": [
            [
              "insert",
              "apple"
            ],
            [
              "insert",
              "app"
            ],
            [
              "insert",
              "application"
            ],
            [
              "suggest",
              "ap"
            ]
          ]
        },
        "output": [
          "app",
          "apple",
          "application"
        ],
        "description": "Suggestions for 'ap' prefix"
      },
      {
        "input": {
          "operations": [
            [
              "insert",
              "hello"
            ],
            [
              "suggest",
              "world"
            ]
          ]
        },
        "output": [],
        "description": "No suggestions for unmatched prefix"
      },
      {
        "input": {
          "operations": [
            [
              "suggest",
              ""
            ]
          ]
        },
        "output": [],
        "description": "Empty prefix"
      },
      {
        "input": {
          "operations": [
            [
              "insert",
              ""
            ],
            [
              "suggest",
              ""
            ]
          ]
        },
        "output": [
          ""
        ],
        "description": "Empty word and prefix"
      }
    ],
    "code": "import { ExerciseMetadata, ExampleCase } from '@interfaces/exercises';\n\n/**\n * Trie-based Autocomplete Exercise Implementation\n * \n * DESCRIPTION:\n * Trie for inserting words and suggesting completions for a prefix.\n * \n * EXAMPLE:\n * insert(\"apple\"); insert(\"app\"); suggest(\"ap\") → [\"app\", \"apple\"]\n * \n * CONCEPTS:\n * - Tree data structures\n * - DFS traversal\n * \n * PERFORMANCE:\n * - Time: O(k) insert/suggest (k word length)\n * - Space: O(total chars)\n * \n * Multiple implementations included to show different approaches.\n */\n\n// Trie Node\nclass TrieNode {\n  children: Map<string, TrieNode>;\n  isWord: boolean;\n\n  constructor() {\n    this.children = new Map();\n    this.isWord = false;\n  }\n}\n\n// Main class (Map-based)\nexport class Trie {\n  private root: TrieNode;\n\n  constructor() {\n    this.root = new TrieNode();\n  }\n\n  insert(word: string): void {\n    if (typeof word !== 'string') {\n      throw new Error(\"Input must be a string\");\n    }\n    let node = this.root;\n    for (const char of word) {\n      if (!node.children.has(char)) {\n        node.children.set(char, new TrieNode());\n      }\n      node = node.children.get(char)!;\n    }\n    node.isWord = true;\n  }\n\n  suggest(prefix: string): string[] {\n    if (typeof prefix !== 'string') {\n      throw new Error(\"Input must be a string\");\n    }\n    let node = this.root;\n    for (const char of prefix) {\n      if (!node.children.has(char)) {\n        return [];\n      }\n      node = node.children.get(char)!;\n    }\n    const results: string[] = [];\n    const dfs = (curr: TrieNode, path: string) => {\n      if (curr.isWord) results.push(path);\n      for (const [char, child] of curr.children) {\n        dfs(child, path + char);\n      }\n    };\n    dfs(node, prefix);\n    return results;\n  }\n}\n\n// Alternative class (array-based for lowercase a-z)\nclass TrieNodeArray {\n  children: (TrieNodeArray | null)[];\n  isWord: boolean;\n\n  constructor() {\n    this.children = Array(26).fill(null);\n    this.isWord = false;\n  }\n}\n\nexport class TrieArray {\n  private root: TrieNodeArray;\n\n  constructor() {\n    this.root = new TrieNodeArray();\n  }\n\n  insert(word: string): void {\n    if (typeof word !== 'string') {\n      throw new Error(\"Input must be a string\");\n    }\n    let node = this.root;\n    for (const char of word.toLowerCase()) {\n      const index = char.charCodeAt(0) - 'a'.charCodeAt(0);\n      if (index < 0 || index > 25) throw new Error(\"Word must contain lowercase letters only\");\n      if (!node.children[index]) {\n        node.children[index] = new TrieNodeArray();\n      }\n      node = node.children[index]!;\n    }\n    node.isWord = true;\n  }\n\n  suggest(prefix: string): string[] {\n    if (typeof prefix !== 'string') {\n      throw new Error(\"Input must be a string\");\n    }\n    let node = this.root;\n    for (const char of prefix.toLowerCase()) {\n      const index = char.charCodeAt(0) - 'a'.charCodeAt(0);\n      if (index < 0 || index > 25 || !node.children[index]) return [];\n      node = node.children[index]!;\n    }\n    const results: string[] = [];\n    const dfs = (curr: TrieNodeArray, path: string) => {\n      if (curr.isWord) results.push(path);\n      for (let k = 0; k < 26; k++) {\n        if (curr.children[k]) {\n          dfs(curr.children[k]!, path + String.fromCharCode(k + 'a'.charCodeAt(0)));\n        }\n      }\n    };\n    dfs(node, prefix);\n    return results;\n  }\n}\n\n// Exercise metadata\nexport const metadata: ExerciseMetadata = {\n  title: \"Trie-based Autocomplete\",\n  description: \"Trie for inserting words and suggesting completions for a prefix\",\n  concepts: [\"tree data structures\", \"DFS traversal\"],\n  timeComplexity: \"O(k) insert/suggest\",\n  spaceComplexity: \"O(total chars)\"\n};\n\n// Example test cases\nexport const examples: ExampleCase[] = [\n  {\n    input: { operations: [[\"insert\", \"apple\"], [\"insert\", \"app\"], [\"insert\", \"application\"], [\"suggest\", \"ap\"]] },\n    output: [\"app\", \"apple\", \"application\"],\n    description: \"Suggestions for 'ap' prefix\"\n  },\n  {\n    input: { operations: [[\"insert\", \"hello\"], [\"suggest\", \"world\"]] },\n    output: [],\n    description: \"No suggestions for unmatched prefix\"\n  },\n  {\n    input: { operations: [[\"suggest\", \"\"]] },\n    output: [],\n    description: \"Empty prefix\"\n  },\n  {\n    input: { operations: [[\"insert\", \"\"], [\"suggest\", \"\"]] },\n    output: [\"\"],\n    description: \"Empty word and prefix\"\n  }\n];\n\n// Default export for easy importing\nexport default { Trie, TrieArray, metadata, examples };",
    "functions": [
      "Trie",
      "TrieArray"
    ]
  },
  {
    "name": "TwoSum",
    "slug": "two-sum",
    "metadata": {
      "title": "Two Sum",
      "description": "Finds two indices in an array whose values sum to a target",
      "concepts": [
        "array iteration",
        "hash maps",
        "brute-force"
      ],
      "timeComplexity": "O(n) for hash map, O(n²) for brute-force",
      "spaceComplexity": "O(n) for hash map, O(1) for brute-force"
    },
    "examples": [
      {
        "input": [
          [
            2,
            7,
            11,
            15
          ],
          9
        ],
        "output": [
          0,
          1
        ],
        "description": "Basic"
      },
      {
        "input": [
          [
            3,
            2,
            4
          ],
          6
        ],
        "output": [
          1,
          2
        ],
        "description": "Not at start"
      },
      {
        "input": [
          [
            3,
            3
          ],
          6
        ],
        "output": [
          0,
          1
        ],
        "description": "Duplicates"
      },
      {
        "input": [
          [
            1,
            2,
            3
          ],
          10
        ],
        "output": {},
        "description": "No solution"
      },
      {
        "input": [
          [
            1
          ],
          2
        ],
        "output": {},
        "description": "Too short"
      },
      {
        "input": [
          null,
          5
        ],
        "output": {},
        "description": "Invalid"
      }
    ],
    "code": "import { ExerciseMetadata, ExampleCase } from '@interfaces/exercises';\n\n/**\n * Two Sum Exercise Implementation\n * \n * DESCRIPTION:\n * Finds two indices in an array summing to target.\n * \n * EXAMPLE:\n * [2, 7, 11, 15], 9 → [0, 1]\n * \n * CONCEPTS:\n * - Iteration\n * - Hash maps\n * \n * PERFORMANCE:\n * - Time: O(n) hash, O(n²) brute\n * - Space: O(n) hash, O(1) brute\n * \n * Multiple implementations included to show different approaches.\n */\n\nexport function twoSum(nums: number[], target: number): number[] {\n  if (!Array.isArray(nums) || nums.length < 2) throw new Error(\"Input must be an array with at least two numbers\");\n  const numToIndex: { [key: number]: number } = {};\n  for (let i = 0; i < nums.length; i++) {\n    const complement = target - nums[i];\n    if (numToIndex[complement] !== undefined) return [numToIndex[complement], i];\n    numToIndex[nums[i]] = i;\n  }\n  throw new Error(\"No two numbers sum to the target\");\n}\n\nexport function twoSumBruteForce(nums: number[], target: number): number[] {\n  if (!Array.isArray(nums) || nums.length < 2) throw new Error(\"Input must be an array with at least two numbers\");\n  for (let i = 0; i < nums.length - 1; i++) {\n    for (let j = i + 1; j < nums.length; j++) {\n      if (nums[i] + nums[j] === target) return [i, j];\n    }\n  }\n  throw new Error(\"No two numbers sum to the target\");\n}\n\nexport const metadata: ExerciseMetadata = {\n  title: \"Two Sum\",\n  description: \"Finds two indices in an array whose values sum to a target\",\n  concepts: [\"array iteration\", \"hash maps\", \"brute-force\"],\n  timeComplexity: \"O(n) for hash map, O(n²) for brute-force\",\n  spaceComplexity: \"O(n) for hash map, O(1) for brute-force\"\n};\n\nexport const examples: ExampleCase[] = [\n  { input: [[2, 7, 11, 15], 9], output: [0, 1], description: \"Basic\" },\n  { input: [[3, 2, 4], 6], output: [1, 2], description: \"Not at start\" },\n  { input: [[3, 3], 6], output: [0, 1], description: \"Duplicates\" },\n  { input: [[1, 2, 3], 10], output: new Error(\"No two numbers sum to the target\"), description: \"No solution\" },\n  { input: [[1], 2], output: new Error(\"Input must be an array with at least two numbers\"), description: \"Too short\" },\n  { input: [null, 5], output: new Error(\"Input must be an array with at least two numbers\"), description: \"Invalid\" }\n];\n\nexport default { twoSum, twoSumBruteForce, metadata, examples };",
    "functions": [
      "twoSum",
      "twoSumBruteForce"
    ]
  }
]