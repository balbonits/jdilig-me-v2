{"name":"Memoize","slug":"Memoize","metadata":{"title":"Memoize Function","description":"Caches function results to avoid expensive recalculations, improving performance for pure functions with predictable inputs","category":"Performance","concepts":["closures","caching","performance optimization","pure functions"],"timeComplexity":"O(1) for cache hits, O(f) for new calculations","spaceComplexity":"O(n) where n is unique argument combinations","difficulty":"Medium","examples":["memoize(expensiveCalculation) → Cached version that stores results"],"performanceNotes":"- Time: O(1) for cache hits, O(f) for cache misses\n - Space: O(n) where n is unique argument combinations"},"examples":[{"input":"fibonacci(40)","output":"102334155","description":"Recursive function optimization","code":"const fibonacci = (n: number): number => {\n  if (n <= 1) return n;\n  return fibonacci(n - 1) + fibonacci(n - 2);\n};\n\nconst memoizedFib = memoize(fibonacci);\n\n// Without memoization: ~1.5 seconds\n// With memoization: ~1 millisecond\nconsole.time('memoized');\nmemoizedFib(40); // 102334155\nconsole.timeEnd('memoized');"},{"input":"apiCall('users')","output":"cached data","description":"API response caching with TTL","code":"const fetchUsers = async (endpoint: string) => {\n  const response = await fetch(`/api/${endpoint}`);\n  return response.json();\n};\n\nconst cachedFetch = memoizeTTL(fetchUsers, 60000); // 1 minute cache\n\n// First call: makes HTTP request\nawait cachedFetch('users');\n\n// Subsequent calls within 1 minute: returns cached data\nawait cachedFetch('users'); // No HTTP request made"},{"input":"expensiveCalc(data)","output":"result","description":"LRU cache for memory management","code":"const processLargeDataset = (data: unknown[]) => {\n  // Expensive computation\n  return data.reduce((acc, item) => \n    acc + complexCalculation(item), 0);\n};\n\nconst memoizedProcess = memoizeLRU(processLargeDataset, 50);\n\n// Only keeps 50 most recent results in memory\nfor (let i = 0; i < 100; i++) {\n  memoizedProcess(generateData(i));\n}\n// Memory usage stays constant"},{"input":"hash('password')","output":"hashed value","description":"Simple memoization for single arguments","code":"const expensiveHash = (input: string) => {\n  // Simulate expensive hashing operation\n  let hash = 0;\n  for (let i = 0; i < input.length * 1000; i++) {\n    hash = ((hash << 5) - hash + input.charCodeAt(i % input.length)) & 0xffffffff;\n  }\n  return hash.toString(16);\n};\n\nconst memoizedHash = memoizeSimple(expensiveHash);\n\n// First call: performs expensive calculation\nmemoizedHash('password123'); // Takes time\n\n// Subsequent calls: instant return\nmemoizedHash('password123'); // Instant"}],"code":"import type { UtilityMetadata, UtilityExample } from '@/interfaces/utilities';\nimport type { SolutionMetadata } from '@/interfaces/shared';\n\n/**\n * Memoize Utility Implementation\n * \n * DESCRIPTION:\n * Caches function results to avoid expensive recalculations for identical inputs.\n * Improves performance for pure functions with predictable argument patterns.\n * \n * ENHANCED METADATA:\n * - Difficulty: Medium (cache management and closure patterns)\n * - Solution Type: function (higher-order function with caching)\n * - Time Complexity: O(1) for cached results, O(f) for new calculations\n * - Space Complexity: O(n) where n is number of unique argument combinations\n * - Concepts: Closures, Caching, Performance optimization, Pure functions\n * - Category: Performance optimization utility\n * \n * EXAMPLE:\n * memoize(expensiveCalculation) → Cached version that stores results\n * \n * CONCEPTS:\n * - Closures and lexical scoping\n * - Caching strategies\n * - Performance optimization\n * - Pure function requirements\n * - Memory management\n * \n * PERFORMANCE:\n * - Time: O(1) for cache hits, O(f) for cache misses\n * - Space: O(n) where n is unique argument combinations\n * \n * Multiple implementations included to show different approaches.\n */\n\n// Basic memoize implementation\nexport function memoize<Args extends unknown[], Return>(\n  fn: (...args: Args) => Return,\n  keyGenerator?: (...args: Args) => string\n): (...args: Args) => Return {\n  if (typeof fn !== 'function') throw new Error(\"First argument must be a function\");\n  \n  const cache = new Map<string, Return>();\n  \n  const generateKey = keyGenerator || ((...args: Args) => JSON.stringify(args));\n  \n  return (...args: Args): Return => {\n    const key = generateKey(...args);\n    \n    if (cache.has(key)) {\n      return cache.get(key)!;\n    }\n    \n    const result = fn(...args);\n    cache.set(key, result);\n    return result;\n  };\n}\n\n// Memoize with LRU cache to prevent memory leaks\nexport function memoizeLRU<Args extends unknown[], Return>(\n  fn: (...args: Args) => Return,\n  maxSize: number = 100,\n  keyGenerator?: (...args: Args) => string\n): (...args: Args) => Return {\n  if (typeof fn !== 'function') throw new Error(\"First argument must be a function\");\n  if (!Number.isInteger(maxSize) || maxSize <= 0) throw new Error(\"Max size must be a positive integer\");\n  \n  const cache = new Map<string, Return>();\n  const generateKey = keyGenerator || ((...args: Args) => JSON.stringify(args));\n  \n  return (...args: Args): Return => {\n    const key = generateKey(...args);\n    \n    if (cache.has(key)) {\n      // Move to end (most recently used)\n      const value = cache.get(key)!;\n      cache.delete(key);\n      cache.set(key, value);\n      return value;\n    }\n    \n    const result = fn(...args);\n    \n    // Remove oldest if at capacity\n    if (cache.size >= maxSize) {\n      const firstKey = cache.keys().next().value;\n      if (firstKey !== undefined) {\n        cache.delete(firstKey);\n      }\n    }\n    \n    cache.set(key, result);\n    return result;\n  };\n}\n\n// Memoize with TTL (Time To Live)\nexport function memoizeTTL<Args extends unknown[], Return>(\n  fn: (...args: Args) => Return,\n  ttlMs: number = 60000,\n  keyGenerator?: (...args: Args) => string\n): (...args: Args) => Return {\n  if (typeof fn !== 'function') throw new Error(\"First argument must be a function\");\n  if (!Number.isInteger(ttlMs) || ttlMs <= 0) throw new Error(\"TTL must be a positive integer\");\n  \n  const cache = new Map<string, { value: Return; timestamp: number }>();\n  const generateKey = keyGenerator || ((...args: Args) => JSON.stringify(args));\n  \n  return (...args: Args): Return => {\n    const key = generateKey(...args);\n    const now = Date.now();\n    \n    if (cache.has(key)) {\n      const cached = cache.get(key);\n      if (cached && now - cached.timestamp < ttlMs) {\n        return cached.value;\n      }\n      cache.delete(key);\n    }\n    \n    const result = fn(...args);\n    cache.set(key, { value: result, timestamp: now });\n    return result;\n  };\n}\n\n// Simple memoize for single-argument functions\nexport function memoizeSimple<T, R>(fn: (arg: T) => R): (arg: T) => R {\n  if (typeof fn !== 'function') throw new Error(\"Argument must be a function\");\n  \n  const cache = new Map<T, R>();\n  \n  return (arg: T): R => {\n    if (cache.has(arg)) {\n      return cache.get(arg)!;\n    }\n    \n    const result = fn(arg);\n    cache.set(arg, result);\n    return result;\n  };\n}\n\n// Utility metadata\nexport const metadata: UtilityMetadata = {\n  title: \"Memoize Function\",\n  description: \"Caches function results to avoid expensive recalculations, improving performance for pure functions with predictable inputs\",\n  category: \"Performance\",\n  concepts: [\"closures\", \"caching\", \"performance optimization\", \"pure functions\"],\n  timeComplexity: \"O(1) for cache hits, O(f) for new calculations\",\n  spaceComplexity: \"O(n) where n is unique argument combinations\",\n  difficulty: \"Medium\"\n};\n\nexport const solutions: SolutionMetadata[] = [\n  {\n    name: \"memoize\",\n    tabName: \"Basic\",\n    approach: \"Simple memoization with Map-based cache\",\n    timeComplexity: \"O(1)\",\n    spaceComplexity: \"O(n)\",\n    isOptimal: true,\n    type: \"function\"\n  },\n  {\n    name: \"memoizeLRU\",\n    tabName: \"LRU\",\n    approach: \"LRU cache to prevent unlimited memory growth\",\n    timeComplexity: \"O(1)\",\n    spaceComplexity: \"O(k)\",\n    isOptimal: true,\n    type: \"function\"\n  },\n  {\n    name: \"memoizeTTL\",\n    tabName: \"TTL\",\n    approach: \"Time-based cache expiration for fresh data\",\n    timeComplexity: \"O(1)\",\n    spaceComplexity: \"O(n)\",\n    isOptimal: false,\n    type: \"function\"\n  },\n  {\n    name: \"memoizeSimple\",\n    tabName: \"Simple\",\n    approach: \"Optimized memoization for single-argument functions\",\n    timeComplexity: \"O(1)\",\n    spaceComplexity: \"O(n)\",\n    isOptimal: true,\n    type: \"function\"\n  }\n];\n\n// Example use cases\nexport const examples: UtilityExample[] = [\n  {\n    input: \"fibonacci(40)\",\n    output: \"102334155\",\n    description: \"Recursive function optimization\",\n    code: `const fibonacci = (n: number): number => {\n  if (n <= 1) return n;\n  return fibonacci(n - 1) + fibonacci(n - 2);\n};\n\nconst memoizedFib = memoize(fibonacci);\n\n// Without memoization: ~1.5 seconds\n// With memoization: ~1 millisecond\nconsole.time('memoized');\nmemoizedFib(40); // 102334155\nconsole.timeEnd('memoized');`\n  },\n  {\n    input: \"apiCall('users')\",\n    output: \"cached data\",\n    description: \"API response caching with TTL\",\n    code: `const fetchUsers = async (endpoint: string) => {\n  const response = await fetch(\\`/api/\\${endpoint}\\`);\n  return response.json();\n};\n\nconst cachedFetch = memoizeTTL(fetchUsers, 60000); // 1 minute cache\n\n// First call: makes HTTP request\nawait cachedFetch('users');\n\n// Subsequent calls within 1 minute: returns cached data\nawait cachedFetch('users'); // No HTTP request made`\n  },\n  {\n    input: \"expensiveCalc(data)\",\n    output: \"result\",\n    description: \"LRU cache for memory management\",\n    code: `const processLargeDataset = (data: unknown[]) => {\n  // Expensive computation\n  return data.reduce((acc, item) => \n    acc + complexCalculation(item), 0);\n};\n\nconst memoizedProcess = memoizeLRU(processLargeDataset, 50);\n\n// Only keeps 50 most recent results in memory\nfor (let i = 0; i < 100; i++) {\n  memoizedProcess(generateData(i));\n}\n// Memory usage stays constant`\n  },\n  {\n    input: \"hash('password')\",\n    output: \"hashed value\",\n    description: \"Simple memoization for single arguments\",\n    code: `const expensiveHash = (input: string) => {\n  // Simulate expensive hashing operation\n  let hash = 0;\n  for (let i = 0; i < input.length * 1000; i++) {\n    hash = ((hash << 5) - hash + input.charCodeAt(i % input.length)) & 0xffffffff;\n  }\n  return hash.toString(16);\n};\n\nconst memoizedHash = memoizeSimple(expensiveHash);\n\n// First call: performs expensive calculation\nmemoizedHash('password123'); // Takes time\n\n// Subsequent calls: instant return\nmemoizedHash('password123'); // Instant`\n  }\n];\n\n// Default export for easy importing\nconst utilityModule = {\n  memoize,\n  memoizeLRU,\n  memoizeTTL,\n  memoizeSimple,\n  metadata,\n  solutions,\n  examples\n};\n\nexport default utilityModule;","functions":["memoize","memoizeLRU","memoizeTTL","memoizeSimple"],"solutions":[{"name":"memoize","tabName":"Basic","code":"export function memoize<Args extends unknown[], Return>(\n  fn: (...args: Args) => Return,\n  keyGenerator?: (...args: Args) => string\n): (...args: Args) => Return {\n  if (typeof fn !== 'function') throw new Error(\"First argument must be a function\");\n  \n  const cache = new Map<string, Return>();\n  \n  const generateKey = keyGenerator || ((...args: Args) => JSON.stringify(args));\n  \n  return (...args: Args): Return => {\n    const key = generateKey(...args);\n    \n    if (cache.has(key)) {\n      return cache.get(key)!;\n    }\n    \n    const result = fn(...args);\n    cache.set(key, result);\n    return result;\n  };\n}\n\n// Memoize with LRU cache to prevent memory leaks","approach":"Basic","timeComplexity":"O(1)","spaceComplexity":"O(n)","isOptimal":true,"type":"function"},{"name":"memoizeLRU","tabName":"LRU","code":"export function memoizeLRU<Args extends unknown[], Return>(\n  fn: (...args: Args) => Return,\n  maxSize: number = 100,\n  keyGenerator?: (...args: Args) => string\n): (...args: Args) => Return {\n  if (typeof fn !== 'function') throw new Error(\"First argument must be a function\");\n  if (!Number.isInteger(maxSize) || maxSize <= 0) throw new Error(\"Max size must be a positive integer\");\n  \n  const cache = new Map<string, Return>();\n  const generateKey = keyGenerator || ((...args: Args) => JSON.stringify(args));\n  \n  return (...args: Args): Return => {\n    const key = generateKey(...args);\n    \n    if (cache.has(key)) {\n      // Move to end (most recently used)\n      const value = cache.get(key)!;\n      cache.delete(key);\n      cache.set(key, value);\n      return value;\n    }\n    \n    const result = fn(...args);\n    \n    // Remove oldest if at capacity\n    if (cache.size >= maxSize) {\n      const firstKey = cache.keys().next().value;\n      if (firstKey !== undefined) {\n        cache.delete(firstKey);\n      }\n    }\n    \n    cache.set(key, result);\n    return result;\n  };\n}\n\n// Memoize with TTL (Time To Live)","approach":"LRU","timeComplexity":"O(1)","spaceComplexity":"O(k)","isOptimal":true,"type":"function"},{"name":"memoizeTTL","tabName":"TTL","code":"export function memoizeTTL<Args extends unknown[], Return>(\n  fn: (...args: Args) => Return,\n  ttlMs: number = 60000,\n  keyGenerator?: (...args: Args) => string\n): (...args: Args) => Return {\n  if (typeof fn !== 'function') throw new Error(\"First argument must be a function\");\n  if (!Number.isInteger(ttlMs) || ttlMs <= 0) throw new Error(\"TTL must be a positive integer\");\n  \n  const cache = new Map<string, { value: Return; timestamp: number }>();\n  const generateKey = keyGenerator || ((...args: Args) => JSON.stringify(args));\n  \n  return (...args: Args): Return => {\n    const key = generateKey(...args);\n    const now = Date.now();\n    \n    if (cache.has(key)) {\n      const cached = cache.get(key);\n      if (cached && now - cached.timestamp < ttlMs) {\n        return cached.value;\n      }\n      cache.delete(key);\n    }\n    \n    const result = fn(...args);\n    cache.set(key, { value: result, timestamp: now });\n    return result;\n  };\n}\n\n// Simple memoize for single-argument functions","approach":"TTL","timeComplexity":"O(1)","spaceComplexity":"O(n)","isOptimal":false,"type":"function"},{"name":"memoizeSimple","tabName":"Simple","code":"export function memoizeSimple<T, R>(fn: (arg: T) => R): (arg: T) => R {\n  if (typeof fn !== 'function') throw new Error(\"Argument must be a function\");\n  \n  const cache = new Map<T, R>();\n  \n  return (arg: T): R => {\n    if (cache.has(arg)) {\n      return cache.get(arg)!;\n    }\n    \n    const result = fn(arg);\n    cache.set(arg, result);\n    return result;\n  };\n}\n\n// Utility metadata","approach":"Simple","timeComplexity":"O(1)","spaceComplexity":"O(n)","isOptimal":true,"type":"function"}]}