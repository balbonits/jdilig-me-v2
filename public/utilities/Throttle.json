{"name":"Throttle","slug":"Throttle","metadata":{"title":"Throttle Function","description":"Limits function execution to at most once per specified time period, ensuring regular execution during continuous events","category":"Performance","concepts":["closures","higher-order functions","rate limiting","performance"],"timeComplexity":"O(1) per call","spaceComplexity":"O(1) per throttled function","difficulty":"Easy","examples":["throttle(handleScroll, 100) → Executes handleScroll max once per 100ms"],"performanceNotes":"- Time: O(1) per call\n - Space: O(1) per throttled function"},"examples":[{"input":"(function, 100)","output":"throttled function","description":"Scroll event optimization","code":"const throttledScroll = throttle(handleScroll, 100);\nwindow.addEventListener('scroll', throttledScroll);\n\n// handleScroll executes maximum once per 100ms during scrolling"},{"input":"(function, 250)","output":"throttled function","description":"Button click protection","code":"const throttledSubmit = throttle(submitForm, 250);\nbutton.addEventListener('click', throttledSubmit);\n\n// Prevents rapid-fire clicks, allows max 4 submissions per second"},{"input":"(function, 500, options)","output":"throttled function","description":"Advanced throttle with options","code":"const throttledResize = throttleAdvanced(updateLayout, 500, {\n  leading: true,\n  trailing: false\n});\nwindow.addEventListener('resize', throttledResize);\n\n// Executes immediately, then ignores calls for 500ms"},{"input":"(function, 1000)","output":"throttled function","description":"API request rate limiting","code":"const throttledApi = throttleImmediate(fetchData, 1000);\nsearchInput.addEventListener('input', () => throttledApi(query));\n\n// API calls limited to once per second maximum"}],"code":"import type { UtilityMetadata, UtilityExample } from '@/interfaces/utilities';\nimport type { SolutionMetadata } from '@/interfaces/shared';\n\n/**\n * Throttle Utility Implementation\n * \n * DESCRIPTION:\n * Limits function execution to at most once per specified time period.\n * Unlike debounce, throttle ensures regular execution during continuous events.\n * \n * ENHANCED METADATA:\n * - Difficulty: Easy (closure pattern with timing control)\n * - Solution Type: function (higher-order function implementation)\n * - Time Complexity: O(1) per call\n * - Space Complexity: O(1) per throttled function\n * - Concepts: Closures, Higher-order functions, Rate limiting, Performance\n * - Category: Performance optimization utility\n * \n * EXAMPLE:\n * throttle(handleScroll, 100) → Executes handleScroll max once per 100ms\n * \n * CONCEPTS:\n * - Closures and lexical scoping\n * - Higher-order functions\n * - Rate limiting vs debouncing\n * - Performance optimization\n * \n * PERFORMANCE:\n * - Time: O(1) per call\n * - Space: O(1) per throttled function\n * \n * Multiple implementations included to show different approaches.\n */\n\n// Function type that can be throttled\nexport type ThrottlableFunction = (...args: (string | number | boolean | Event)[]) => void | Promise<void>;\n\nexport function throttle<T extends ThrottlableFunction>(\n  func: T,\n  wait: number\n): (...args: Parameters<T>) => void {\n  if (typeof func !== 'function') throw new Error(\"First argument must be a function\");\n  if (!Number.isInteger(wait) || wait < 0) throw new Error(\"Wait time must be a non-negative integer\");\n  \n  let lastCall = 0;\n\n  return (...args: Parameters<T>) => {\n    const now = Date.now();\n    if (now - lastCall >= wait) {\n      lastCall = now;\n      func(...args);\n    }\n  };\n}\n\n// Alternative implementation with leading and trailing options\nexport function throttleAdvanced<T extends ThrottlableFunction>(\n  func: T,\n  wait: number,\n  options: { leading?: boolean; trailing?: boolean } = {}\n): (...args: Parameters<T>) => void {\n  if (typeof func !== 'function') throw new Error(\"First argument must be a function\");\n  if (!Number.isInteger(wait) || wait < 0) throw new Error(\"Wait time must be a non-negative integer\");\n  \n  const { leading = true, trailing = true } = options;\n  let timeout: NodeJS.Timeout | null = null;\n  let lastCall = 0;\n  let lastArgs: Parameters<T> | null = null;\n\n  return (...args: Parameters<T>) => {\n    const now = Date.now();\n    lastArgs = args;\n\n    if (!lastCall && leading === false) {\n      lastCall = now;\n    }\n\n    const remaining = wait - (now - lastCall);\n\n    if (remaining <= 0 || remaining > wait) {\n      if (timeout) {\n        clearTimeout(timeout);\n        timeout = null;\n      }\n      lastCall = now;\n      func(...args);\n    } else if (!timeout && trailing) {\n      timeout = setTimeout(() => {\n        lastCall = leading === false ? 0 : Date.now();\n        timeout = null;\n        if (lastArgs) func(...lastArgs);\n      }, remaining);\n    }\n  };\n}\n\n// Simple throttle with immediate execution\nexport function throttleImmediate<T extends ThrottlableFunction>(\n  func: T,\n  wait: number\n): (...args: Parameters<T>) => void {\n  if (typeof func !== 'function') throw new Error(\"First argument must be a function\");\n  if (!Number.isInteger(wait) || wait < 0) throw new Error(\"Wait time must be a non-negative integer\");\n  \n  let inThrottle = false;\n\n  return (...args: Parameters<T>) => {\n    if (!inThrottle) {\n      func(...args);\n      inThrottle = true;\n      setTimeout(() => {\n        inThrottle = false;\n      }, wait);\n    }\n  };\n}\n\n// Utility metadata\nexport const metadata: UtilityMetadata = {\n  title: \"Throttle Function\",\n  description: \"Limits function execution to at most once per specified time period, ensuring regular execution during continuous events\",\n  category: \"Performance\",\n  concepts: [\"closures\", \"higher-order functions\", \"rate limiting\", \"performance\"],\n  timeComplexity: \"O(1) per call\",\n  spaceComplexity: \"O(1) per throttled function\",\n  difficulty: \"Easy\"\n};\n\nexport const solutions: SolutionMetadata[] = [\n  {\n    name: \"throttle\",\n    tabName: \"Standard\",\n    approach: \"Basic throttle with timestamp checking\",\n    timeComplexity: \"O(1)\",\n    spaceComplexity: \"O(1)\",\n    isOptimal: true,\n    type: \"function\"\n  },\n  {\n    name: \"throttleAdvanced\",\n    tabName: \"Advanced\",\n    approach: \"Throttle with leading/trailing execution options\",\n    timeComplexity: \"O(1)\",\n    spaceComplexity: \"O(1)\",\n    isOptimal: true,\n    type: \"function\"\n  },\n  {\n    name: \"throttleImmediate\",\n    tabName: \"Immediate\",\n    approach: \"Simple throttle with immediate execution flag\",\n    timeComplexity: \"O(1)\",\n    spaceComplexity: \"O(1)\",\n    isOptimal: true,\n    type: \"function\"\n  }\n];\n\n// Example use cases\nexport const examples: UtilityExample[] = [\n  {\n    input: \"(function, 100)\",\n    output: \"throttled function\",\n    description: \"Scroll event optimization\",\n    code: `const throttledScroll = throttle(handleScroll, 100);\nwindow.addEventListener('scroll', throttledScroll);\n\n// handleScroll executes maximum once per 100ms during scrolling`\n  },\n  {\n    input: \"(function, 250)\",\n    output: \"throttled function\",\n    description: \"Button click protection\",\n    code: `const throttledSubmit = throttle(submitForm, 250);\nbutton.addEventListener('click', throttledSubmit);\n\n// Prevents rapid-fire clicks, allows max 4 submissions per second`\n  },\n  {\n    input: \"(function, 500, options)\",\n    output: \"throttled function\",\n    description: \"Advanced throttle with options\",\n    code: `const throttledResize = throttleAdvanced(updateLayout, 500, {\n  leading: true,\n  trailing: false\n});\nwindow.addEventListener('resize', throttledResize);\n\n// Executes immediately, then ignores calls for 500ms`\n  },\n  {\n    input: \"(function, 1000)\",\n    output: \"throttled function\",\n    description: \"API request rate limiting\",\n    code: `const throttledApi = throttleImmediate(fetchData, 1000);\nsearchInput.addEventListener('input', () => throttledApi(query));\n\n// API calls limited to once per second maximum`\n  }\n];\n\n// Default export for easy importing\nconst utilityModule = {\n  throttle,\n  throttleAdvanced,\n  throttleImmediate,\n  metadata,\n  solutions,\n  examples\n};\n\nexport default utilityModule;","functions":["throttle","throttleAdvanced","throttleImmediate"],"solutions":[{"name":"throttle","tabName":"Standard","code":"export function throttle<T extends ThrottlableFunction>(\n  func: T,\n  wait: number\n): (...args: Parameters<T>) => void {\n  if (typeof func !== 'function') throw new Error(\"First argument must be a function\");\n  if (!Number.isInteger(wait) || wait < 0) throw new Error(\"Wait time must be a non-negative integer\");\n  \n  let lastCall = 0;\n\n  return (...args: Parameters<T>) => {\n    const now = Date.now();\n    if (now - lastCall >= wait) {\n      lastCall = now;\n      func(...args);\n    }\n  };\n}\n\n// Alternative implementation with leading and trailing options","approach":"Standard","timeComplexity":"O(1)","spaceComplexity":"O(1)","isOptimal":true,"type":"function"},{"name":"throttleAdvanced","tabName":"Advanced","code":"export function throttleAdvanced<T extends ThrottlableFunction>(\n  func: T,\n  wait: number,\n  options: { leading?: boolean; trailing?: boolean } = {}\n): (...args: Parameters<T>) => void {\n  if (typeof func !== 'function') throw new Error(\"First argument must be a function\");\n  if (!Number.isInteger(wait) || wait < 0) throw new Error(\"Wait time must be a non-negative integer\");\n  \n  const { leading = true, trailing = true } = options;\n  let timeout: NodeJS.Timeout | null = null;\n  let lastCall = 0;\n  let lastArgs: Parameters<T> | null = null;\n\n  return (...args: Parameters<T>) => {\n    const now = Date.now();\n    lastArgs = args;\n\n    if (!lastCall && leading === false) {\n      lastCall = now;\n    }\n\n    const remaining = wait - (now - lastCall);\n\n    if (remaining <= 0 || remaining > wait) {\n      if (timeout) {\n        clearTimeout(timeout);\n        timeout = null;\n      }\n      lastCall = now;\n      func(...args);\n    } else if (!timeout && trailing) {\n      timeout = setTimeout(() => {\n        lastCall = leading === false ? 0 : Date.now();\n        timeout = null;\n        if (lastArgs) func(...lastArgs);\n      }, remaining);\n    }\n  };\n}\n\n// Simple throttle with immediate execution","approach":"Advanced","timeComplexity":"O(1)","spaceComplexity":"O(1)","isOptimal":true,"type":"function"},{"name":"throttleImmediate","tabName":"Immediate","code":"export function throttleImmediate<T extends ThrottlableFunction>(\n  func: T,\n  wait: number\n): (...args: Parameters<T>) => void {\n  if (typeof func !== 'function') throw new Error(\"First argument must be a function\");\n  if (!Number.isInteger(wait) || wait < 0) throw new Error(\"Wait time must be a non-negative integer\");\n  \n  let inThrottle = false;\n\n  return (...args: Parameters<T>) => {\n    if (!inThrottle) {\n      func(...args);\n      inThrottle = true;\n      setTimeout(() => {\n        inThrottle = false;\n      }, wait);\n    }\n  };\n}\n\n// Utility metadata","approach":"Immediate","timeComplexity":"O(1)","spaceComplexity":"O(1)","isOptimal":true,"type":"function"}]}