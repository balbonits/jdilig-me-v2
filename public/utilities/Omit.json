{"name":"Omit","slug":"Omit","metadata":{"title":"Omit Function","description":"Creates new objects by excluding specified properties, supporting various filtering strategies including nested paths and predicates","category":"Data Manipulation","concepts":["object manipulation","property filtering","immutability","type safety"],"timeComplexity":"O(n) where n is source object properties","spaceComplexity":"O(k) where k is result object properties","difficulty":"Easy","examples":["omit({ a: 1, b: 2, c: 3 }, ['b']) → { a: 1, c: 3 }"],"performanceNotes":"- Time: O(n) where n is source object properties\n - Space: O(k) where k is result object properties"},"examples":[{"input":"{ a: 1, b: 2, c: 3 }, ['b']","output":"{ a: 1, c: 3 }","description":"Basic property omission","code":"const user = {\n  id: 1,\n  name: 'John Doe',\n  email: 'john@example.com',\n  password: 'secret123',\n  role: 'admin',\n  createdAt: '2024-01-01'\n};\n\n// Remove sensitive information\nconst publicUser = omit(user, ['password']);\nconsole.log(publicUser);\n// { id: 1, name: 'John Doe', email: 'john@example.com', role: 'admin', createdAt: '2024-01-01' }\n\n// Remove multiple properties\nconst basicUser = omit(user, ['password', 'role', 'createdAt']);\nconsole.log(basicUser);\n// { id: 1, name: 'John Doe', email: 'john@example.com' }\n\n// Convenience method for single key\nconst withoutEmail = omitSingle(user, 'email');\nconsole.log(withoutEmail);\n// { id: 1, name: 'John Doe', password: 'secret123', role: 'admin', createdAt: '2024-01-01' }"},{"input":"API response filtering","output":"cleaned response","description":"API response sanitization and filtering","code":"interface ApiResponse {\n  success: boolean;\n  data: {\n    user: {\n      id: number;\n      name: string;\n      email: string;\n      internalId: string;\n      debug: any;\n    };\n    metadata: {\n      requestId: string;\n      timestamp: string;\n      version: string;\n      debug: any;\n    };\n  };\n  debug: any;\n  internalFields: any;\n}\n\nconst apiResponse: ApiResponse = {\n  success: true,\n  data: {\n    user: {\n      id: 1,\n      name: 'John',\n      email: 'john@example.com',\n      internalId: 'internal-123',\n      debug: { trace: 'xyz' }\n    },\n    metadata: {\n      requestId: 'req-456',\n      timestamp: '2024-01-01',\n      version: '1.0',\n      debug: { performance: '100ms' }\n    }\n  },\n  debug: { sql: 'SELECT * FROM users' },\n  internalFields: { cache: 'hit' }\n};\n\n// Remove debug and internal fields\nconst cleanResponse = omit(apiResponse, ['debug', 'internalFields']);\n\n// Remove nested debug fields\nconst deepCleanResponse = omitDeep(cleanResponse, [\n  'data.user.debug',\n  'data.user.internalId',\n  'data.metadata.debug'\n]);\n\nconsole.log(deepCleanResponse);\n// Clean response without any debug or internal information"},{"input":"conditional filtering","output":"filtered object","description":"Conditional property omission with predicates","code":"const formData = {\n  name: 'John',\n  email: 'john@example.com',\n  age: 30,\n  phone: '',\n  address: null,\n  newsletter: false,\n  terms: true,\n  comments: undefined,\n  score: 0\n};\n\n// Remove empty/null/undefined values\nconst nonEmptyData = omitBy(formData, (value) => {\n  return value === null || value === undefined || value === '';\n});\nconsole.log(nonEmptyData);\n// { name: 'John', email: 'john@example.com', age: 30, newsletter: false, terms: true, score: 0 }\n\n// Remove false boolean values only\nconst truthyBooleans = omitBy(formData, (value, key) => {\n  return typeof value === 'boolean' && value === false;\n});\n\n// Remove by type\nconst noStrings = omitByType(formData, ['string']);\nconsole.log(noStrings);\n// { age: 30, address: null, newsletter: false, terms: true, score: 0 }\n\n// Remove by pattern (fields ending with 'Id' or containing 'temp')\nconst config = {\n  userId: 123,\n  userName: 'john',\n  tempData: 'cache',\n  apiKey: 'secret',\n  tempConfig: 'dev',\n  sessionId: 'abc123'\n};\n\nconst filtered = omitByPattern(config, [/Id$/, /temp/i]);\nconsole.log(filtered);\n// { userName: 'john', apiKey: 'secret' }"},{"input":"form processing","output":"processed form","description":"Form data processing and validation preparation","code":"interface FormInput {\n  // User fields\n  firstName: string;\n  lastName: string;\n  email: string;\n  phone: string;\n  \n  // UI state (should not be sent to API)\n  isLoading: boolean;\n  showPassword: boolean;\n  formTouched: boolean;\n  \n  // Validation fields (internal use)\n  firstNameError?: string;\n  lastNameError?: string;\n  emailError?: string;\n  \n  // Meta fields\n  timestamp: string;\n  userAgent: string;\n}\n\nconst formInput: FormInput = {\n  firstName: 'John',\n  lastName: 'Doe',\n  email: 'john@example.com',\n  phone: '+1234567890',\n  isLoading: false,\n  showPassword: false,\n  formTouched: true,\n  firstNameError: undefined,\n  emailError: 'Invalid format',\n  timestamp: '2024-01-01T10:00:00Z',\n  userAgent: 'Mozilla/5.0...'\n};\n\n// Prepare data for API submission (remove UI state and validation fields)\nconst apiData = omitByPattern(formInput, [\n  /^is[A-Z]/,     // Remove isLoading, etc.\n  /^show[A-Z]/,   // Remove showPassword, etc.\n  /Error$/,       // Remove validation errors\n  /^form[A-Z]/    // Remove formTouched, etc.\n]);\n\n// Further clean for specific endpoint\nconst userOnlyData = omit(apiData, ['timestamp', 'userAgent']);\nconsole.log(userOnlyData);\n// { firstName: 'John', lastName: 'Doe', email: 'john@example.com', phone: '+1234567890' }\n\n// Create analytics data (keep only meta fields)\nconst analyticsData = omitBy(formInput, (value, key) => {\n  const metaFields = ['timestamp', 'userAgent', 'formTouched'];\n  return !metaFields.includes(String(key));\n});"}],"code":"import type { UtilityMetadata, UtilityExample } from '@/interfaces/utilities';\nimport type { SolutionMetadata } from '@/interfaces/shared';\n\n/**\n * Omit Utility Implementation\n * \n * DESCRIPTION:\n * Creates a new object by excluding specified properties from the source object.\n * Essential for object manipulation, API response filtering, and data transformation.\n * \n * ENHANCED METADATA:\n * - Difficulty: Easy (object manipulation and filtering)\n * - Solution Type: function (object property filtering utility)\n * - Time Complexity: O(n) where n is number of properties in source object\n * - Space Complexity: O(k) where k is number of properties in result object\n * - Concepts: Object manipulation, Property filtering, Immutability, Type safety\n * - Category: Data manipulation utility\n * \n * EXAMPLE:\n * omit({ a: 1, b: 2, c: 3 }, ['b']) → { a: 1, c: 3 }\n * \n * CONCEPTS:\n * - Object property manipulation\n * - Immutable data transformations\n * - Array and object iteration\n * - TypeScript generics and type safety\n * \n * PERFORMANCE:\n * - Time: O(n) where n is source object properties\n * - Space: O(k) where k is result object properties\n * \n * Multiple implementations included to show different approaches.\n */\n\n// Basic omit implementation\nexport function omit<T extends Record<string, unknown>, K extends keyof T>(\n  obj: T,\n  keys: K[]\n): Omit<T, K> {\n  if (obj == null || typeof obj !== 'object') {\n    throw new Error('First argument must be an object');\n  }\n  \n  if (!Array.isArray(keys)) {\n    throw new Error('Second argument must be an array of keys');\n  }\n  \n  const result = {} as Omit<T, K>;\n  const keysToOmit = new Set(keys);\n  \n  for (const key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key) && !keysToOmit.has(key as unknown as K)) {\n      (result as Record<string, unknown>)[key] = obj[key];\n    }\n  }\n  \n  return result;\n}\n\n// Omit with single key (convenience overload)\nexport function omitSingle<T extends Record<string, unknown>, K extends keyof T>(\n  obj: T,\n  key: K\n): Omit<T, K> {\n  return omit(obj, [key]);\n}\n\n// Omit with nested path support\nexport function omitDeep<T extends Record<string, unknown>>(\n  obj: T,\n  paths: string[]\n): Partial<T> {\n  if (obj == null || typeof obj !== 'object') {\n    throw new Error('First argument must be an object');\n  }\n  \n  if (!Array.isArray(paths)) {\n    throw new Error('Second argument must be an array of paths');\n  }\n  \n  const result = { ...obj };\n  \n  for (const path of paths) {\n    const keys = path.split('.');\n    let current: Record<string, unknown> = result;\n    \n    for (let i = 0; i < keys.length - 1; i++) {\n      const key = keys[i];\n      if (current[key] && typeof current[key] === 'object') {\n        current[key] = { ...current[key] };\n        current = current[key] as Record<string, unknown>;\n      } else {\n        break;\n      }\n    }\n    \n    const lastKey = keys[keys.length - 1];\n    if (current && typeof current === 'object' && lastKey in current) {\n      delete current[lastKey];\n    }\n  }\n  \n  return result;\n}\n\n// Omit with predicate function\nexport function omitBy<T extends Record<string, unknown>>(\n  obj: T,\n  predicate: (value: T[keyof T], key: keyof T) => boolean\n): Partial<T> {\n  if (obj == null || typeof obj !== 'object') {\n    throw new Error('First argument must be an object');\n  }\n  \n  if (typeof predicate !== 'function') {\n    throw new Error('Second argument must be a function');\n  }\n  \n  const result = {} as Partial<T>;\n  \n  for (const key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n      const value = obj[key];\n      if (!predicate(value, key)) {\n        (result as Record<string, unknown>)[key] = value;\n      }\n    }\n  }\n  \n  return result;\n}\n\n// Omit using rest parameters for convenience\nexport function omitKeys<T extends Record<string, unknown>, K extends keyof T>(\n  obj: T,\n  ...keys: K[]\n): Omit<T, K> {\n  return omit(obj, keys);\n}\n\n// Omit with type predicate for runtime type checking\nexport function omitByType<T extends Record<string, unknown>>(\n  obj: T,\n  types: string[]\n): Partial<T> {\n  if (obj == null || typeof obj !== 'object') {\n    throw new Error('First argument must be an object');\n  }\n  \n  if (!Array.isArray(types)) {\n    throw new Error('Second argument must be an array of type strings');\n  }\n  \n  const typesToOmit = new Set(types);\n  const result = {} as Partial<T>;\n  \n  for (const key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n      const value = obj[key];\n      const valueType = value === null ? 'null' : typeof value;\n      \n      if (!typesToOmit.has(valueType)) {\n        (result as Record<string, unknown>)[key] = value;\n      }\n    }\n  }\n  \n  return result;\n}\n\n// Omit with regex pattern matching\nexport function omitByPattern<T extends Record<string, unknown>>(\n  obj: T,\n  patterns: RegExp[]\n): Partial<T> {\n  if (obj == null || typeof obj !== 'object') {\n    throw new Error('First argument must be an object');\n  }\n  \n  if (!Array.isArray(patterns)) {\n    throw new Error('Second argument must be an array of RegExp patterns');\n  }\n  \n  const result = {} as Partial<T>;\n  \n  for (const key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n      const shouldOmit = patterns.some(pattern => pattern.test(String(key)));\n      \n      if (!shouldOmit) {\n        (result as Record<string, unknown>)[key] = obj[key];\n      }\n    }\n  }\n  \n  return result;\n}\n\n// Utility metadata\nexport const metadata: UtilityMetadata = {\n  title: \"Omit Function\",\n  description: \"Creates new objects by excluding specified properties, supporting various filtering strategies including nested paths and predicates\",\n  category: \"Data Manipulation\",\n  concepts: [\"object manipulation\", \"property filtering\", \"immutability\", \"type safety\"],\n  timeComplexity: \"O(n) where n is source object properties\",\n  spaceComplexity: \"O(k) where k is result object properties\",\n  difficulty: \"Easy\"\n};\n\nexport const solutions: SolutionMetadata[] = [\n  {\n    name: \"omit\",\n    tabName: \"Basic\",\n    approach: \"Standard property omission with type safety\",\n    timeComplexity: \"O(n)\",\n    spaceComplexity: \"O(k)\",\n    isOptimal: true,\n    type: \"function\"\n  },\n  {\n    name: \"omitDeep\",\n    tabName: \"Deep\",\n    approach: \"Nested path omission with dot notation support\",\n    timeComplexity: \"O(n×d)\",\n    spaceComplexity: \"O(k)\",\n    isOptimal: false,\n    type: \"function\"\n  },\n  {\n    name: \"omitBy\",\n    tabName: \"Predicate\",\n    approach: \"Conditional omission using predicate function\",\n    timeComplexity: \"O(n)\",\n    spaceComplexity: \"O(k)\",\n    isOptimal: true,\n    type: \"function\"\n  },\n  {\n    name: \"omitByPattern\",\n    tabName: \"Pattern\",\n    approach: \"Regex pattern-based property omission\",\n    timeComplexity: \"O(n×p)\",\n    spaceComplexity: \"O(k)\",\n    isOptimal: false,\n    type: \"function\"\n  }\n];\n\n// Example use cases\nexport const examples: UtilityExample[] = [\n  {\n    input: \"{ a: 1, b: 2, c: 3 }, ['b']\",\n    output: \"{ a: 1, c: 3 }\",\n    description: \"Basic property omission\",\n    code: `const user = {\n  id: 1,\n  name: 'John Doe',\n  email: 'john@example.com',\n  password: 'secret123',\n  role: 'admin',\n  createdAt: '2024-01-01'\n};\n\n// Remove sensitive information\nconst publicUser = omit(user, ['password']);\nconsole.log(publicUser);\n// { id: 1, name: 'John Doe', email: 'john@example.com', role: 'admin', createdAt: '2024-01-01' }\n\n// Remove multiple properties\nconst basicUser = omit(user, ['password', 'role', 'createdAt']);\nconsole.log(basicUser);\n// { id: 1, name: 'John Doe', email: 'john@example.com' }\n\n// Convenience method for single key\nconst withoutEmail = omitSingle(user, 'email');\nconsole.log(withoutEmail);\n// { id: 1, name: 'John Doe', password: 'secret123', role: 'admin', createdAt: '2024-01-01' }`\n  },\n  {\n    input: \"API response filtering\",\n    output: \"cleaned response\",\n    description: \"API response sanitization and filtering\",\n    code: `interface ApiResponse {\n  success: boolean;\n  data: {\n    user: {\n      id: number;\n      name: string;\n      email: string;\n      internalId: string;\n      debug: any;\n    };\n    metadata: {\n      requestId: string;\n      timestamp: string;\n      version: string;\n      debug: any;\n    };\n  };\n  debug: any;\n  internalFields: any;\n}\n\nconst apiResponse: ApiResponse = {\n  success: true,\n  data: {\n    user: {\n      id: 1,\n      name: 'John',\n      email: 'john@example.com',\n      internalId: 'internal-123',\n      debug: { trace: 'xyz' }\n    },\n    metadata: {\n      requestId: 'req-456',\n      timestamp: '2024-01-01',\n      version: '1.0',\n      debug: { performance: '100ms' }\n    }\n  },\n  debug: { sql: 'SELECT * FROM users' },\n  internalFields: { cache: 'hit' }\n};\n\n// Remove debug and internal fields\nconst cleanResponse = omit(apiResponse, ['debug', 'internalFields']);\n\n// Remove nested debug fields\nconst deepCleanResponse = omitDeep(cleanResponse, [\n  'data.user.debug',\n  'data.user.internalId',\n  'data.metadata.debug'\n]);\n\nconsole.log(deepCleanResponse);\n// Clean response without any debug or internal information`\n  },\n  {\n    input: \"conditional filtering\",\n    output: \"filtered object\",\n    description: \"Conditional property omission with predicates\",\n    code: `const formData = {\n  name: 'John',\n  email: 'john@example.com',\n  age: 30,\n  phone: '',\n  address: null,\n  newsletter: false,\n  terms: true,\n  comments: undefined,\n  score: 0\n};\n\n// Remove empty/null/undefined values\nconst nonEmptyData = omitBy(formData, (value) => {\n  return value === null || value === undefined || value === '';\n});\nconsole.log(nonEmptyData);\n// { name: 'John', email: 'john@example.com', age: 30, newsletter: false, terms: true, score: 0 }\n\n// Remove false boolean values only\nconst truthyBooleans = omitBy(formData, (value, key) => {\n  return typeof value === 'boolean' && value === false;\n});\n\n// Remove by type\nconst noStrings = omitByType(formData, ['string']);\nconsole.log(noStrings);\n// { age: 30, address: null, newsletter: false, terms: true, score: 0 }\n\n// Remove by pattern (fields ending with 'Id' or containing 'temp')\nconst config = {\n  userId: 123,\n  userName: 'john',\n  tempData: 'cache',\n  apiKey: 'secret',\n  tempConfig: 'dev',\n  sessionId: 'abc123'\n};\n\nconst filtered = omitByPattern(config, [/Id$/, /temp/i]);\nconsole.log(filtered);\n// { userName: 'john', apiKey: 'secret' }`\n  },\n  {\n    input: \"form processing\",\n    output: \"processed form\",\n    description: \"Form data processing and validation preparation\",\n    code: `interface FormInput {\n  // User fields\n  firstName: string;\n  lastName: string;\n  email: string;\n  phone: string;\n  \n  // UI state (should not be sent to API)\n  isLoading: boolean;\n  showPassword: boolean;\n  formTouched: boolean;\n  \n  // Validation fields (internal use)\n  firstNameError?: string;\n  lastNameError?: string;\n  emailError?: string;\n  \n  // Meta fields\n  timestamp: string;\n  userAgent: string;\n}\n\nconst formInput: FormInput = {\n  firstName: 'John',\n  lastName: 'Doe',\n  email: 'john@example.com',\n  phone: '+1234567890',\n  isLoading: false,\n  showPassword: false,\n  formTouched: true,\n  firstNameError: undefined,\n  emailError: 'Invalid format',\n  timestamp: '2024-01-01T10:00:00Z',\n  userAgent: 'Mozilla/5.0...'\n};\n\n// Prepare data for API submission (remove UI state and validation fields)\nconst apiData = omitByPattern(formInput, [\n  /^is[A-Z]/,     // Remove isLoading, etc.\n  /^show[A-Z]/,   // Remove showPassword, etc.\n  /Error$/,       // Remove validation errors\n  /^form[A-Z]/    // Remove formTouched, etc.\n]);\n\n// Further clean for specific endpoint\nconst userOnlyData = omit(apiData, ['timestamp', 'userAgent']);\nconsole.log(userOnlyData);\n// { firstName: 'John', lastName: 'Doe', email: 'john@example.com', phone: '+1234567890' }\n\n// Create analytics data (keep only meta fields)\nconst analyticsData = omitBy(formInput, (value, key) => {\n  const metaFields = ['timestamp', 'userAgent', 'formTouched'];\n  return !metaFields.includes(String(key));\n});`\n  }\n];\n\n// Default export for easy importing\nconst utilityModule = {\n  omit,\n  omitSingle,\n  omitDeep,\n  omitBy,\n  omitKeys,\n  omitByType,\n  omitByPattern,\n  metadata,\n  solutions,\n  examples\n};\n\nexport default utilityModule;","functions":["omit","omitSingle","omitDeep","omitBy","omitKeys","omitByType","omitByPattern"],"solutions":[{"name":"omit","tabName":"Basic","code":"export function omit<T extends Record<string, unknown>, K extends keyof T>(\n  obj: T,\n  keys: K[]\n): Omit<T, K> {\n  if (obj == null || typeof obj !== 'object') {\n    throw new Error('First argument must be an object');\n  }\n  \n  if (!Array.isArray(keys)) {\n    throw new Error('Second argument must be an array of keys');\n  }\n  \n  const result = {} as Omit<T, K>;\n  const keysToOmit = new Set(keys);\n  \n  for (const key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key) && !keysToOmit.has(key as unknown as K)) {\n      (result as Record<string, unknown>)[key] = obj[key];\n    }\n  }\n  \n  return result;\n}\n\n// Omit with single key (convenience overload)","approach":"Basic","timeComplexity":"O(n)","spaceComplexity":"O(k)","isOptimal":true,"type":"function"},{"name":"omitDeep","tabName":"Deep","code":"export function omitDeep<T extends Record<string, unknown>>(\n  obj: T,\n  paths: string[]\n): Partial<T> {\n  if (obj == null || typeof obj !== 'object') {\n    throw new Error('First argument must be an object');\n  }\n  \n  if (!Array.isArray(paths)) {\n    throw new Error('Second argument must be an array of paths');\n  }\n  \n  const result = { ...obj };\n  \n  for (const path of paths) {\n    const keys = path.split('.');\n    let current: Record<string, unknown> = result;\n    \n    for (let i = 0; i < keys.length - 1; i++) {\n      const key = keys[i];\n      if (current[key] && typeof current[key] === 'object') {\n        current[key] = { ...current[key] };\n        current = current[key] as Record<string, unknown>;\n      } else {\n        break;\n      }\n    }\n    \n    const lastKey = keys[keys.length - 1];\n    if (current && typeof current === 'object' && lastKey in current) {\n      delete current[lastKey];\n    }\n  }\n  \n  return result;\n}\n\n// Omit with predicate function","approach":"Deep","timeComplexity":"O(n×d)","spaceComplexity":"O(k)","isOptimal":false,"type":"function"},{"name":"omitBy","tabName":"Predicate","code":"export function omitBy<T extends Record<string, unknown>>(\n  obj: T,\n  predicate: (value: T[keyof T], key: keyof T) => boolean\n): Partial<T> {\n  if (obj == null || typeof obj !== 'object') {\n    throw new Error('First argument must be an object');\n  }\n  \n  if (typeof predicate !== 'function') {\n    throw new Error('Second argument must be a function');\n  }\n  \n  const result = {} as Partial<T>;\n  \n  for (const key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n      const value = obj[key];\n      if (!predicate(value, key)) {\n        (result as Record<string, unknown>)[key] = value;\n      }\n    }\n  }\n  \n  return result;\n}\n\n// Omit using rest parameters for convenience","approach":"Predicate","timeComplexity":"O(n)","spaceComplexity":"O(k)","isOptimal":true,"type":"function"},{"name":"omitByPattern","tabName":"Pattern","code":"export function omitByPattern<T extends Record<string, unknown>>(\n  obj: T,\n  patterns: RegExp[]\n): Partial<T> {\n  if (obj == null || typeof obj !== 'object') {\n    throw new Error('First argument must be an object');\n  }\n  \n  if (!Array.isArray(patterns)) {\n    throw new Error('Second argument must be an array of RegExp patterns');\n  }\n  \n  const result = {} as Partial<T>;\n  \n  for (const key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n      const shouldOmit = patterns.some(pattern => pattern.test(String(key)));\n      \n      if (!shouldOmit) {\n        (result as Record<string, unknown>)[key] = obj[key];\n      }\n    }\n  }\n  \n  return result;\n}\n\n// Utility metadata","approach":"Pattern","timeComplexity":"O(n×p)","spaceComplexity":"O(k)","isOptimal":false,"type":"function"}]}