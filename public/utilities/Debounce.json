{"name":"Debounce","slug":"Debounce","metadata":{"title":"Debounce Function","description":"Delays function execution until a specified wait time has elapsed since the last call, optimizing performance for frequent events","category":"Performance","concepts":["closures","higher-order functions","event optimization","performance"],"timeComplexity":"O(1) per call","spaceComplexity":"O(1) per debounced function","difficulty":"Easy","examples":["debounce(handleSearch, 300) → Returns function that delays handleSearch by 300ms"],"performanceNotes":"- Time: O(1) per call\n - Space: O(1) per debounced function"},"examples":[{"input":"(function, 300)","output":"debounced function","description":"Basic debounce for search input","code":"const debouncedSearch = debounce(handleSearch, 300);\ninput.addEventListener('input', (e) => debouncedSearch(e.target.value));\n\n// Function will only execute 300ms after the last input event"},{"input":"(function, 200)","output":"debounced function","description":"Optimize window resize events","code":"const debouncedResize = debounce(updateLayout, 200);\nwindow.addEventListener('resize', debouncedResize);\n\n// Layout updates only after resize events stop for 200ms"},{"input":"(function, 500, true)","output":"debounced function","description":"Immediate execution with debounce","code":"const debouncedSubmit = debounceImmediate(submitForm, 500, true);\nbutton.addEventListener('click', debouncedSubmit);\n\n// Executes immediately, then prevents subsequent calls for 500ms"},{"input":"(function, 1000)","output":"debounced function","description":"API rate limiting","code":"const debouncedApiCall = debounce(fetchData, 1000);\nsearchInput.addEventListener('input', () => debouncedApiCall(query));\n\n// API calls limited to maximum once per second"}],"code":"import type { UtilityMetadata, UtilityExample } from '@/interfaces/utilities';\nimport type { SolutionMetadata } from '@/interfaces/shared';\n\n/**\n * Debounce Utility Implementation\n * \n * DESCRIPTION:\n * Delays function execution until a specified wait time has elapsed since the last call.\n * Useful for rate-limiting event handlers like scroll, resize, or input events.\n * \n * ENHANCED METADATA:\n * - Difficulty: Easy (straightforward closure pattern)\n * - Solution Type: function (higher-order function implementation)\n * - Time Complexity: O(1) per call\n * - Space Complexity: O(1) per debounced function\n * - Concepts: Closures, Higher-order functions, Event optimization, Performance\n * - Category: Performance optimization utility\n * \n * EXAMPLE:\n * debounce(handleSearch, 300) → Returns function that delays handleSearch by 300ms\n * \n * CONCEPTS:\n * - Closures and lexical scoping\n * - Higher-order functions\n * - Event optimization\n * - Performance optimization\n * \n * PERFORMANCE:\n * - Time: O(1) per call\n * - Space: O(1) per debounced function\n * \n * Multiple implementations included to show different approaches.\n */\n\n// Function type that can be debounced\nexport type DebouncableFunction = (...args: (string | number | boolean | Event)[]) => void | Promise<void>;\n\nexport function debounce<T extends DebouncableFunction>(\n  func: T,\n  wait: number\n): (...args: Parameters<T>) => void {\n  if (typeof func !== 'function') throw new Error(\"First argument must be a function\");\n  if (!Number.isInteger(wait) || wait < 0) throw new Error(\"Wait time must be a non-negative integer\");\n  \n  let timeout: NodeJS.Timeout | null = null;\n\n  return (...args: Parameters<T>) => {\n    if (timeout) {\n      clearTimeout(timeout);\n    }\n    timeout = setTimeout(() => {\n      func(...args);\n    }, wait);\n  };\n}\n\n// Alternative implementation with immediate execution option\nexport function debounceImmediate<T extends DebouncableFunction>(\n  func: T,\n  wait: number,\n  immediate: boolean = false\n): (...args: Parameters<T>) => void {\n  if (typeof func !== 'function') throw new Error(\"First argument must be a function\");\n  if (!Number.isInteger(wait) || wait < 0) throw new Error(\"Wait time must be a non-negative integer\");\n  \n  let timeout: NodeJS.Timeout | null = null;\n\n  return (...args: Parameters<T>) => {\n    const callNow = immediate && !timeout;\n    \n    if (timeout) {\n      clearTimeout(timeout);\n    }\n    \n    timeout = setTimeout(() => {\n      timeout = null;\n      if (!immediate) func(...args);\n    }, wait);\n    \n    if (callNow) func(...args);\n  };\n}\n\n// Utility metadata\nexport const metadata: UtilityMetadata = {\n  title: \"Debounce Function\",\n  description: \"Delays function execution until a specified wait time has elapsed since the last call, optimizing performance for frequent events\",\n  category: \"Performance\",\n  concepts: [\"closures\", \"higher-order functions\", \"event optimization\", \"performance\"],\n  timeComplexity: \"O(1) per call\",\n  spaceComplexity: \"O(1) per debounced function\",\n  difficulty: \"Easy\"\n};\n\nexport const solutions: SolutionMetadata[] = [\n  {\n    name: \"debounce\",\n    tabName: \"Standard\",\n    approach: \"Basic debounce with timeout clearing\",\n    timeComplexity: \"O(1)\",\n    spaceComplexity: \"O(1)\",\n    isOptimal: true,\n    type: \"function\"\n  },\n  {\n    name: \"debounceImmediate\",\n    tabName: \"Immediate\",\n    approach: \"Debounce with optional immediate execution\",\n    timeComplexity: \"O(1)\",\n    spaceComplexity: \"O(1)\",\n    isOptimal: true,\n    type: \"function\"\n  }\n];\n\n// Example use cases\nexport const examples: UtilityExample[] = [\n  {\n    input: \"(function, 300)\",\n    output: \"debounced function\",\n    description: \"Basic debounce for search input\",\n    code: `const debouncedSearch = debounce(handleSearch, 300);\ninput.addEventListener('input', (e) => debouncedSearch(e.target.value));\n\n// Function will only execute 300ms after the last input event`\n  },\n  {\n    input: \"(function, 200)\",\n    output: \"debounced function\",\n    description: \"Optimize window resize events\",\n    code: `const debouncedResize = debounce(updateLayout, 200);\nwindow.addEventListener('resize', debouncedResize);\n\n// Layout updates only after resize events stop for 200ms`\n  },\n  {\n    input: \"(function, 500, true)\",\n    output: \"debounced function\",\n    description: \"Immediate execution with debounce\",\n    code: `const debouncedSubmit = debounceImmediate(submitForm, 500, true);\nbutton.addEventListener('click', debouncedSubmit);\n\n// Executes immediately, then prevents subsequent calls for 500ms`\n  },\n  {\n    input: \"(function, 1000)\",\n    output: \"debounced function\", \n    description: \"API rate limiting\",\n    code: `const debouncedApiCall = debounce(fetchData, 1000);\nsearchInput.addEventListener('input', () => debouncedApiCall(query));\n\n// API calls limited to maximum once per second`\n  }\n];\n\n// Default export for easy importing\nconst utilityModule = {\n  debounce,\n  debounceImmediate,\n  metadata,\n  solutions,\n  examples\n};\n\nexport default utilityModule;","functions":["debounce","debounceImmediate"],"solutions":[{"name":"debounce","tabName":"Standard","code":"export function debounce<T extends DebouncableFunction>(\n  func: T,\n  wait: number\n): (...args: Parameters<T>) => void {\n  if (typeof func !== 'function') throw new Error(\"First argument must be a function\");\n  if (!Number.isInteger(wait) || wait < 0) throw new Error(\"Wait time must be a non-negative integer\");\n  \n  let timeout: NodeJS.Timeout | null = null;\n\n  return (...args: Parameters<T>) => {\n    if (timeout) {\n      clearTimeout(timeout);\n    }\n    timeout = setTimeout(() => {\n      func(...args);\n    }, wait);\n  };\n}\n\n// Alternative implementation with immediate execution option","approach":"Standard","timeComplexity":"O(1)","spaceComplexity":"O(1)","isOptimal":true,"type":"function"},{"name":"debounceImmediate","tabName":"Immediate","code":"export function debounceImmediate<T extends DebouncableFunction>(\n  func: T,\n  wait: number,\n  immediate: boolean = false\n): (...args: Parameters<T>) => void {\n  if (typeof func !== 'function') throw new Error(\"First argument must be a function\");\n  if (!Number.isInteger(wait) || wait < 0) throw new Error(\"Wait time must be a non-negative integer\");\n  \n  let timeout: NodeJS.Timeout | null = null;\n\n  return (...args: Parameters<T>) => {\n    const callNow = immediate && !timeout;\n    \n    if (timeout) {\n      clearTimeout(timeout);\n    }\n    \n    timeout = setTimeout(() => {\n      timeout = null;\n      if (!immediate) func(...args);\n    }, wait);\n    \n    if (callNow) func(...args);\n  };\n}\n\n// Utility metadata","approach":"Immediate","timeComplexity":"O(1)","spaceComplexity":"O(1)","isOptimal":true,"type":"function"}]}