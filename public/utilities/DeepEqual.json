{"name":"DeepEqual","slug":"DeepEqual","metadata":{"title":"DeepEqual Function","description":"Performs deep equality comparison between values, handling nested structures, various data types, and circular references","category":"Data Comparison","concepts":["recursion","type checking","object comparison","reference tracking"],"timeComplexity":"O(n) where n is total properties/elements","spaceComplexity":"O(d) where d is maximum depth","difficulty":"Medium","examples":["deepEqual({ a: [1, 2] }, { a: [1, 2] }) → true"],"performanceNotes":"- Time: O(n) where n is total properties/elements to compare\n - Space: O(d) where d is maximum nesting depth"},"examples":[{"input":"two objects","output":"boolean equality","description":"Basic object and array deep comparison","code":"const obj1 = {\n  user: {\n    name: 'John',\n    age: 30,\n    hobbies: ['reading', 'coding'],\n    settings: { theme: 'dark', notifications: true }\n  }\n};\n\nconst obj2 = {\n  user: {\n    name: 'John',\n    age: 30,\n    hobbies: ['reading', 'coding'],\n    settings: { theme: 'dark', notifications: true }\n  }\n};\n\nconst obj3 = {\n  user: {\n    name: 'John',\n    age: 30,\n    hobbies: ['reading', 'gaming'], // Different hobby\n    settings: { theme: 'dark', notifications: true }\n  }\n};\n\nconsole.log(obj1 === obj2);           // false (different references)\nconsole.log(deepEqual(obj1, obj2));   // true (same structure and values)\nconsole.log(deepEqual(obj1, obj3));   // false (different hobbies)"},{"input":"various data types","output":"type-aware comparison","description":"Comparing different JavaScript data types","code":"const complex1 = {\n  date: new Date('2024-01-01'),\n  regex: /test\\d+/gi,\n  set: new Set([1, 2, 3]),\n  map: new Map([['key1', 'value1'], ['key2', 'value2']]),\n  nested: { array: [1, 2, { id: 1 }] }\n};\n\nconst complex2 = {\n  date: new Date('2024-01-01'),\n  regex: /test\\d+/gi,\n  set: new Set([3, 2, 1]), // Different order, but sets are unordered\n  map: new Map([['key2', 'value2'], ['key1', 'value1']]), // Different order\n  nested: { array: [1, 2, { id: 1 }] }\n};\n\nconst complex3 = {\n  date: new Date('2024-01-02'), // Different date\n  regex: /test\\d+/gi,\n  set: new Set([1, 2, 3]),\n  map: new Map([['key1', 'value1'], ['key2', 'value2']]),\n  nested: { array: [1, 2, { id: 1 }] }\n};\n\nconsole.log(deepEqual(complex1, complex2)); // true (logically equal)\nconsole.log(deepEqual(complex1, complex3)); // false (different date)"},{"input":"circular references","output":"safe comparison","description":"Handling circular references in comparison","code":"const obj1: any = { name: 'parent1' };\nobj1.child = { name: 'child1', parent: obj1 };\n\nconst obj2: any = { name: 'parent1' };\nobj2.child = { name: 'child1', parent: obj2 };\n\nconst obj3: any = { name: 'parent2' }; // Different name\nobj3.child = { name: 'child1', parent: obj3 };\n\n// This would cause infinite recursion with basic deepEqual\n// console.log(deepEqual(obj1, obj2)); // Stack overflow!\n\n// Safe comparison with circular reference detection\nconsole.log(deepEqualWithCircularCheck(obj1, obj2)); // true\nconsole.log(deepEqualWithCircularCheck(obj1, obj3)); // false\n\n// Verify structure is intact\nconsole.log(obj1.child.parent === obj1); // true\nconsole.log(obj2.child.parent === obj2); // true"},{"input":"performance comparison","output":"method selection","description":"Choosing the right equality method for your use case","code":"const obj1 = { id: 1, values: [1, 2, 3, 4, 5] };\nconst obj2 = { id: 1, values: [1, 2, 3, 4, 5] };\nconst obj3 = { values: [1, 2, 3, 4, 5], id: 1 }; // Different property order\n\n// Shallow equality (fast, but only checks top level)\nconsole.log(shallowEqual(obj1, obj2));     // false (different array references)\nconsole.log(shallowEqual(obj1.values, obj2.values)); // false (different references)\n\n// Deep equality (thorough, handles nested structures)\nconsole.log(deepEqual(obj1, obj2));        // true (same structure and values)\nconsole.log(deepEqual(obj1, obj3));        // true (property order doesn't matter)\n\n// Strict deep equality (considers property order)\nconsole.log(deepEqualStrict(obj1, obj2));  // true\nconsole.log(deepEqualStrict(obj1, obj3));  // false (different property order)\n\n// JSON equality (fast but limited - no Dates, RegExp, etc.)\nconsole.log(deepEqualJSON(obj1, obj2));    // true\nconsole.log(deepEqualJSON(obj1, obj3));    // false (property order matters in JSON)\n\n// Use cases:\n// - shallowEqual: React props comparison, simple object checks\n// - deepEqual: General purpose deep comparison\n// - deepEqualStrict: When property order matters\n// - deepEqualJSON: Fast comparison of serializable data"}],"code":"import type { UtilityMetadata, UtilityExample } from '@/interfaces/utilities';\nimport type { SolutionMetadata } from '@/interfaces/shared';\n\n/**\n * DeepEqual Utility Implementation\n * \n * DESCRIPTION:\n * Performs deep equality comparison between two values, handling nested objects,\n * arrays, and various JavaScript data types including circular references.\n * \n * ENHANCED METADATA:\n * - Difficulty: Medium (recursive comparison and type handling)\n * - Solution Type: function (recursive equality comparison utility)\n * - Time Complexity: O(n) where n is total number of properties/elements\n * - Space Complexity: O(d) where d is maximum depth of nesting\n * - Concepts: Recursion, Type checking, Object comparison, Reference tracking\n * - Category: Data comparison utility\n * \n * EXAMPLE:\n * deepEqual({ a: [1, 2] }, { a: [1, 2] }) → true\n * \n * CONCEPTS:\n * - Recursive algorithms\n * - Type checking and comparison\n * - Object and array traversal\n * - Reference equality vs value equality\n * - Circular reference handling\n * \n * PERFORMANCE:\n * - Time: O(n) where n is total properties/elements to compare\n * - Space: O(d) where d is maximum nesting depth\n * \n * Multiple implementations included to show different comparison approaches.\n */\n\n// Basic deep equality comparison\nexport function deepEqual(a: unknown, b: unknown): boolean {\n  // Strict equality check (handles primitives, null, undefined, same reference)\n  if (a === b) return true;\n  \n  // Both must be objects from this point\n  if (a == null || b == null) return false;\n  if (typeof a !== 'object' || typeof b !== 'object') return false;\n  \n  // Handle Date objects\n  if (a instanceof Date && b instanceof Date) {\n    return a.getTime() === b.getTime();\n  }\n  \n  // Handle RegExp objects\n  if (a instanceof RegExp && b instanceof RegExp) {\n    return a.source === b.source && a.flags === b.flags;\n  }\n  \n  // Handle Arrays\n  if (Array.isArray(a) && Array.isArray(b)) {\n    if (a.length !== b.length) return false;\n    for (let i = 0; i < a.length; i++) {\n      if (!deepEqual(a[i], b[i])) return false;\n    }\n    return true;\n  }\n  \n  // One is array, other is not\n  if (Array.isArray(a) || Array.isArray(b)) return false;\n  \n  // Handle Set objects\n  if (a instanceof Set && b instanceof Set) {\n    if (a.size !== b.size) return false;\n    for (const value of a) {\n      let found = false;\n      for (const otherValue of b) {\n        if (deepEqual(value, otherValue)) {\n          found = true;\n          break;\n        }\n      }\n      if (!found) return false;\n    }\n    return true;\n  }\n  \n  // Handle Map objects\n  if (a instanceof Map && b instanceof Map) {\n    if (a.size !== b.size) return false;\n    for (const [key, value] of a) {\n      let found = false;\n      for (const [otherKey, otherValue] of b) {\n        if (deepEqual(key, otherKey) && deepEqual(value, otherValue)) {\n          found = true;\n          break;\n        }\n      }\n      if (!found) return false;\n    }\n    return true;\n  }\n  \n  // Different object types\n  if (a.constructor !== b.constructor) return false;\n  \n  // Handle plain objects\n  const keysA = Object.keys(a as object);\n  const keysB = Object.keys(b as object);\n  \n  if (keysA.length !== keysB.length) return false;\n  \n  for (const key of keysA) {\n    if (!Object.prototype.hasOwnProperty.call(b, key)) return false;\n    if (!deepEqual((a as Record<string, unknown>)[key], (b as Record<string, unknown>)[key])) return false;\n  }\n  \n  return true;\n}\n\n// Deep equal with circular reference detection\nexport function deepEqualWithCircularCheck(a: unknown, b: unknown, seenA = new WeakMap(), seenB = new WeakMap()): boolean {\n  // Strict equality check\n  if (a === b) return true;\n  \n  // Both must be objects from this point\n  if (a == null || b == null) return false;\n  if (typeof a !== 'object' || typeof b !== 'object') return false;\n  \n  // Check for circular references\n  if (seenA.has(a as object) && seenB.has(b as object)) {\n    return seenA.get(a as object) === seenB.get(b as object);\n  }\n  \n  if (seenA.has(a as object) || seenB.has(b as object)) {\n    return false;\n  }\n  \n  // Mark as seen\n  const visitIdA = Symbol('visitA');\n  const visitIdB = Symbol('visitB');\n  seenA.set(a as object, visitIdA);\n  seenB.set(b as object, visitIdB);\n  \n  try {\n    // Handle Date objects\n    if (a instanceof Date && b instanceof Date) {\n      return a.getTime() === b.getTime();\n    }\n    \n    // Handle RegExp objects\n    if (a instanceof RegExp && b instanceof RegExp) {\n      return a.source === b.source && a.flags === b.flags;\n    }\n    \n    // Handle Arrays\n    if (Array.isArray(a) && Array.isArray(b)) {\n      if (a.length !== b.length) return false;\n      for (let i = 0; i < a.length; i++) {\n        if (!deepEqualWithCircularCheck(a[i], b[i], seenA, seenB)) return false;\n      }\n      return true;\n    }\n    \n    // One is array, other is not\n    if (Array.isArray(a) || Array.isArray(b)) return false;\n    \n    // Handle Set objects\n    if (a instanceof Set && b instanceof Set) {\n      if (a.size !== b.size) return false;\n      for (const value of a) {\n        let found = false;\n        for (const otherValue of b) {\n          if (deepEqualWithCircularCheck(value, otherValue, seenA, seenB)) {\n            found = true;\n            break;\n          }\n        }\n        if (!found) return false;\n      }\n      return true;\n    }\n    \n    // Handle Map objects\n    if (a instanceof Map && b instanceof Map) {\n      if (a.size !== b.size) return false;\n      for (const [key, value] of a) {\n        let found = false;\n        for (const [otherKey, otherValue] of b) {\n          if (deepEqualWithCircularCheck(key, otherKey, seenA, seenB) && \n              deepEqualWithCircularCheck(value, otherValue, seenA, seenB)) {\n            found = true;\n            break;\n          }\n        }\n        if (!found) return false;\n      }\n      return true;\n    }\n    \n    // Different object types\n    if (a.constructor !== b.constructor) return false;\n    \n    // Handle plain objects\n    const keysA = Object.keys(a as object);\n    const keysB = Object.keys(b as object);\n    \n    if (keysA.length !== keysB.length) return false;\n    \n    for (const key of keysA) {\n      if (!Object.prototype.hasOwnProperty.call(b, key)) return false;\n      if (!deepEqualWithCircularCheck((a as Record<string, unknown>)[key], (b as Record<string, unknown>)[key], seenA, seenB)) return false;\n    }\n    \n    return true;\n  } finally {\n    // Clean up\n    seenA.delete(a as object);\n    seenB.delete(b as object);\n  }\n}\n\n// Shallow equality comparison\nexport function shallowEqual(a: unknown, b: unknown): boolean {\n  if (a === b) return true;\n  \n  if (a == null || b == null) return false;\n  if (typeof a !== 'object' || typeof b !== 'object') return false;\n  \n  // Handle Arrays\n  if (Array.isArray(a) && Array.isArray(b)) {\n    if (a.length !== b.length) return false;\n    for (let i = 0; i < a.length; i++) {\n      if (a[i] !== b[i]) return false;\n    }\n    return true;\n  }\n  \n  if (Array.isArray(a) || Array.isArray(b)) return false;\n  \n  // Handle objects\n  const keysA = Object.keys(a as object);\n  const keysB = Object.keys(b as object);\n  \n  if (keysA.length !== keysB.length) return false;\n  \n  for (const key of keysA) {\n    if (!Object.prototype.hasOwnProperty.call(b, key)) return false;\n    if ((a as Record<string, unknown>)[key] !== (b as Record<string, unknown>)[key]) return false;\n  }\n  \n  return true;\n}\n\n// Strict deep equal (considers property order and more strict type checking)\nexport function deepEqualStrict(a: unknown, b: unknown): boolean {\n  if (a === b) return true;\n  \n  if (a == null || b == null) return false;\n  if (typeof a !== typeof b) return false;\n  if (typeof a !== 'object') return false;\n  \n  // Different constructors\n  if (a.constructor !== b.constructor) return false;\n  \n  // Handle Date objects\n  if (a instanceof Date && b instanceof Date) {\n    return a.getTime() === b.getTime();\n  }\n  \n  // Handle RegExp objects\n  if (a instanceof RegExp && b instanceof RegExp) {\n    return a.source === b.source && a.flags === b.flags;\n  }\n  \n  // Handle Arrays\n  if (Array.isArray(a) && Array.isArray(b)) {\n    if (a.length !== b.length) return false;\n    for (let i = 0; i < a.length; i++) {\n      if (!deepEqualStrict(a[i], b[i])) return false;\n    }\n    return true;\n  }\n  \n  // Handle Set objects\n  if (a instanceof Set && b instanceof Set) {\n    if (a.size !== b.size) return false;\n    const arrA = Array.from(a).sort();\n    const arrB = Array.from(b).sort();\n    return deepEqualStrict(arrA, arrB);\n  }\n  \n  // Handle Map objects\n  if (a instanceof Map && b instanceof Map) {\n    if (a.size !== b.size) return false;\n    const entriesA = Array.from(a.entries()).sort();\n    const entriesB = Array.from(b.entries()).sort();\n    return deepEqualStrict(entriesA, entriesB);\n  }\n  \n  // Handle objects (with property order consideration)\n  const keysA = Object.keys(a as object).sort();\n  const keysB = Object.keys(b as object).sort();\n  \n  if (!deepEqualStrict(keysA, keysB)) return false;\n  \n  for (const key of keysA) {\n    if (!deepEqualStrict((a as Record<string, unknown>)[key], (b as Record<string, unknown>)[key])) return false;\n  }\n  \n  return true;\n}\n\n// Fast equality check using JSON (limited but fast)\nexport function deepEqualJSON(a: unknown, b: unknown): boolean {\n  try {\n    return JSON.stringify(a) === JSON.stringify(b);\n  } catch {\n    return false;\n  }\n}\n\n// Utility metadata\nexport const metadata: UtilityMetadata = {\n  title: \"DeepEqual Function\",\n  description: \"Performs deep equality comparison between values, handling nested structures, various data types, and circular references\",\n  category: \"Data Comparison\",\n  concepts: [\"recursion\", \"type checking\", \"object comparison\", \"reference tracking\"],\n  timeComplexity: \"O(n) where n is total properties/elements\",\n  spaceComplexity: \"O(d) where d is maximum depth\",\n  difficulty: \"Medium\"\n};\n\nexport const solutions: SolutionMetadata[] = [\n  {\n    name: \"deepEqual\",\n    tabName: \"Basic\",\n    approach: \"Recursive deep equality with comprehensive type support\",\n    timeComplexity: \"O(n)\",\n    spaceComplexity: \"O(d)\",\n    isOptimal: true,\n    type: \"function\"\n  },\n  {\n    name: \"deepEqualWithCircularCheck\",\n    tabName: \"Circular Safe\",\n    approach: \"Deep equality with circular reference detection\",\n    timeComplexity: \"O(n)\",\n    spaceComplexity: \"O(d)\",\n    isOptimal: true,\n    type: \"function\"\n  },\n  {\n    name: \"shallowEqual\",\n    tabName: \"Shallow\",\n    approach: \"Fast shallow equality comparison\",\n    timeComplexity: \"O(k)\",\n    spaceComplexity: \"O(1)\",\n    isOptimal: true,\n    type: \"function\"\n  },\n  {\n    name: \"deepEqualJSON\",\n    tabName: \"JSON\",\n    approach: \"Fast JSON-based comparison (limited type support)\",\n    timeComplexity: \"O(n)\",\n    spaceComplexity: \"O(n)\",\n    isOptimal: false,\n    type: \"function\"\n  }\n];\n\n// Example use cases\nexport const examples: UtilityExample[] = [\n  {\n    input: \"two objects\",\n    output: \"boolean equality\",\n    description: \"Basic object and array deep comparison\",\n    code: `const obj1 = {\n  user: {\n    name: 'John',\n    age: 30,\n    hobbies: ['reading', 'coding'],\n    settings: { theme: 'dark', notifications: true }\n  }\n};\n\nconst obj2 = {\n  user: {\n    name: 'John',\n    age: 30,\n    hobbies: ['reading', 'coding'],\n    settings: { theme: 'dark', notifications: true }\n  }\n};\n\nconst obj3 = {\n  user: {\n    name: 'John',\n    age: 30,\n    hobbies: ['reading', 'gaming'], // Different hobby\n    settings: { theme: 'dark', notifications: true }\n  }\n};\n\nconsole.log(obj1 === obj2);           // false (different references)\nconsole.log(deepEqual(obj1, obj2));   // true (same structure and values)\nconsole.log(deepEqual(obj1, obj3));   // false (different hobbies)`\n  },\n  {\n    input: \"various data types\",\n    output: \"type-aware comparison\",\n    description: \"Comparing different JavaScript data types\",\n    code: `const complex1 = {\n  date: new Date('2024-01-01'),\n  regex: /test\\\\d+/gi,\n  set: new Set([1, 2, 3]),\n  map: new Map([['key1', 'value1'], ['key2', 'value2']]),\n  nested: { array: [1, 2, { id: 1 }] }\n};\n\nconst complex2 = {\n  date: new Date('2024-01-01'),\n  regex: /test\\\\d+/gi,\n  set: new Set([3, 2, 1]), // Different order, but sets are unordered\n  map: new Map([['key2', 'value2'], ['key1', 'value1']]), // Different order\n  nested: { array: [1, 2, { id: 1 }] }\n};\n\nconst complex3 = {\n  date: new Date('2024-01-02'), // Different date\n  regex: /test\\\\d+/gi,\n  set: new Set([1, 2, 3]),\n  map: new Map([['key1', 'value1'], ['key2', 'value2']]),\n  nested: { array: [1, 2, { id: 1 }] }\n};\n\nconsole.log(deepEqual(complex1, complex2)); // true (logically equal)\nconsole.log(deepEqual(complex1, complex3)); // false (different date)`\n  },\n  {\n    input: \"circular references\",\n    output: \"safe comparison\",\n    description: \"Handling circular references in comparison\",\n    code: `const obj1: any = { name: 'parent1' };\nobj1.child = { name: 'child1', parent: obj1 };\n\nconst obj2: any = { name: 'parent1' };\nobj2.child = { name: 'child1', parent: obj2 };\n\nconst obj3: any = { name: 'parent2' }; // Different name\nobj3.child = { name: 'child1', parent: obj3 };\n\n// This would cause infinite recursion with basic deepEqual\n// console.log(deepEqual(obj1, obj2)); // Stack overflow!\n\n// Safe comparison with circular reference detection\nconsole.log(deepEqualWithCircularCheck(obj1, obj2)); // true\nconsole.log(deepEqualWithCircularCheck(obj1, obj3)); // false\n\n// Verify structure is intact\nconsole.log(obj1.child.parent === obj1); // true\nconsole.log(obj2.child.parent === obj2); // true`\n  },\n  {\n    input: \"performance comparison\",\n    output: \"method selection\",\n    description: \"Choosing the right equality method for your use case\",\n    code: `const obj1 = { id: 1, values: [1, 2, 3, 4, 5] };\nconst obj2 = { id: 1, values: [1, 2, 3, 4, 5] };\nconst obj3 = { values: [1, 2, 3, 4, 5], id: 1 }; // Different property order\n\n// Shallow equality (fast, but only checks top level)\nconsole.log(shallowEqual(obj1, obj2));     // false (different array references)\nconsole.log(shallowEqual(obj1.values, obj2.values)); // false (different references)\n\n// Deep equality (thorough, handles nested structures)\nconsole.log(deepEqual(obj1, obj2));        // true (same structure and values)\nconsole.log(deepEqual(obj1, obj3));        // true (property order doesn't matter)\n\n// Strict deep equality (considers property order)\nconsole.log(deepEqualStrict(obj1, obj2));  // true\nconsole.log(deepEqualStrict(obj1, obj3));  // false (different property order)\n\n// JSON equality (fast but limited - no Dates, RegExp, etc.)\nconsole.log(deepEqualJSON(obj1, obj2));    // true\nconsole.log(deepEqualJSON(obj1, obj3));    // false (property order matters in JSON)\n\n// Use cases:\n// - shallowEqual: React props comparison, simple object checks\n// - deepEqual: General purpose deep comparison\n// - deepEqualStrict: When property order matters\n// - deepEqualJSON: Fast comparison of serializable data`\n  }\n];\n\n// Default export for easy importing\nconst utilityModule = {\n  deepEqual,\n  deepEqualWithCircularCheck,\n  shallowEqual,\n  deepEqualStrict,\n  deepEqualJSON,\n  metadata,\n  solutions,\n  examples\n};\n\nexport default utilityModule;","functions":["deepEqual","deepEqualWithCircularCheck","shallowEqual","deepEqualStrict","deepEqualJSON"],"solutions":[{"name":"deepEqual","tabName":"Basic","code":"export function deepEqual(a: unknown, b: unknown): boolean {\n  // Strict equality check (handles primitives, null, undefined, same reference)\n  if (a === b) return true;\n  \n  // Both must be objects from this point\n  if (a == null || b == null) return false;\n  if (typeof a !== 'object' || typeof b !== 'object') return false;\n  \n  // Handle Date objects\n  if (a instanceof Date && b instanceof Date) {\n    return a.getTime() === b.getTime();\n  }\n  \n  // Handle RegExp objects\n  if (a instanceof RegExp && b instanceof RegExp) {\n    return a.source === b.source && a.flags === b.flags;\n  }\n  \n  // Handle Arrays\n  if (Array.isArray(a) && Array.isArray(b)) {\n    if (a.length !== b.length) return false;\n    for (let i = 0; i < a.length; i++) {\n      if (!deepEqual(a[i], b[i])) return false;\n    }\n    return true;\n  }\n  \n  // One is array, other is not\n  if (Array.isArray(a) || Array.isArray(b)) return false;\n  \n  // Handle Set objects\n  if (a instanceof Set && b instanceof Set) {\n    if (a.size !== b.size) return false;\n    for (const value of a) {\n      let found = false;\n      for (const otherValue of b) {\n        if (deepEqual(value, otherValue)) {\n          found = true;\n          break;\n        }\n      }\n      if (!found) return false;\n    }\n    return true;\n  }\n  \n  // Handle Map objects\n  if (a instanceof Map && b instanceof Map) {\n    if (a.size !== b.size) return false;\n    for (const [key, value] of a) {\n      let found = false;\n      for (const [otherKey, otherValue] of b) {\n        if (deepEqual(key, otherKey) && deepEqual(value, otherValue)) {\n          found = true;\n          break;\n        }\n      }\n      if (!found) return false;\n    }\n    return true;\n  }\n  \n  // Different object types\n  if (a.constructor !== b.constructor) return false;\n  \n  // Handle plain objects\n  const keysA = Object.keys(a as object);\n  const keysB = Object.keys(b as object);\n  \n  if (keysA.length !== keysB.length) return false;\n  \n  for (const key of keysA) {\n    if (!Object.prototype.hasOwnProperty.call(b, key)) return false;\n    if (!deepEqual((a as Record<string, unknown>)[key], (b as Record<string, unknown>)[key])) return false;\n  }\n  \n  return true;\n}\n\n// Deep equal with circular reference detection","approach":"Basic","timeComplexity":"O(n)","spaceComplexity":"O(d)","isOptimal":true,"type":"function"},{"name":"deepEqualWithCircularCheck","tabName":"Circular Safe","code":"export function deepEqualWithCircularCheck(a: unknown, b: unknown, seenA = new WeakMap(), seenB = new WeakMap()): boolean {\n  // Strict equality check\n  if (a === b) return true;\n  \n  // Both must be objects from this point\n  if (a == null || b == null) return false;\n  if (typeof a !== 'object' || typeof b !== 'object') return false;\n  \n  // Check for circular references\n  if (seenA.has(a as object) && seenB.has(b as object)) {\n    return seenA.get(a as object) === seenB.get(b as object);\n  }\n  \n  if (seenA.has(a as object) || seenB.has(b as object)) {\n    return false;\n  }\n  \n  // Mark as seen\n  const visitIdA = Symbol('visitA');\n  const visitIdB = Symbol('visitB');\n  seenA.set(a as object, visitIdA);\n  seenB.set(b as object, visitIdB);\n  \n  try {\n    // Handle Date objects\n    if (a instanceof Date && b instanceof Date) {\n      return a.getTime() === b.getTime();\n    }\n    \n    // Handle RegExp objects\n    if (a instanceof RegExp && b instanceof RegExp) {\n      return a.source === b.source && a.flags === b.flags;\n    }\n    \n    // Handle Arrays\n    if (Array.isArray(a) && Array.isArray(b)) {\n      if (a.length !== b.length) return false;\n      for (let i = 0; i < a.length; i++) {\n        if (!deepEqualWithCircularCheck(a[i], b[i], seenA, seenB)) return false;\n      }\n      return true;\n    }\n    \n    // One is array, other is not\n    if (Array.isArray(a) || Array.isArray(b)) return false;\n    \n    // Handle Set objects\n    if (a instanceof Set && b instanceof Set) {\n      if (a.size !== b.size) return false;\n      for (const value of a) {\n        let found = false;\n        for (const otherValue of b) {\n          if (deepEqualWithCircularCheck(value, otherValue, seenA, seenB)) {\n            found = true;\n            break;\n          }\n        }\n        if (!found) return false;\n      }\n      return true;\n    }\n    \n    // Handle Map objects\n    if (a instanceof Map && b instanceof Map) {\n      if (a.size !== b.size) return false;\n      for (const [key, value] of a) {\n        let found = false;\n        for (const [otherKey, otherValue] of b) {\n          if (deepEqualWithCircularCheck(key, otherKey, seenA, seenB) && \n              deepEqualWithCircularCheck(value, otherValue, seenA, seenB)) {\n            found = true;\n            break;\n          }\n        }\n        if (!found) return false;\n      }\n      return true;\n    }\n    \n    // Different object types\n    if (a.constructor !== b.constructor) return false;\n    \n    // Handle plain objects\n    const keysA = Object.keys(a as object);\n    const keysB = Object.keys(b as object);\n    \n    if (keysA.length !== keysB.length) return false;\n    \n    for (const key of keysA) {\n      if (!Object.prototype.hasOwnProperty.call(b, key)) return false;\n      if (!deepEqualWithCircularCheck((a as Record<string, unknown>)[key], (b as Record<string, unknown>)[key], seenA, seenB)) return false;\n    }\n    \n    return true;\n  } finally {\n    // Clean up\n    seenA.delete(a as object);\n    seenB.delete(b as object);\n  }\n}\n\n// Shallow equality comparison","approach":"Circular Safe","timeComplexity":"O(n)","spaceComplexity":"O(d)","isOptimal":true,"type":"function"},{"name":"shallowEqual","tabName":"Shallow","code":"export function shallowEqual(a: unknown, b: unknown): boolean {\n  if (a === b) return true;\n  \n  if (a == null || b == null) return false;\n  if (typeof a !== 'object' || typeof b !== 'object') return false;\n  \n  // Handle Arrays\n  if (Array.isArray(a) && Array.isArray(b)) {\n    if (a.length !== b.length) return false;\n    for (let i = 0; i < a.length; i++) {\n      if (a[i] !== b[i]) return false;\n    }\n    return true;\n  }\n  \n  if (Array.isArray(a) || Array.isArray(b)) return false;\n  \n  // Handle objects\n  const keysA = Object.keys(a as object);\n  const keysB = Object.keys(b as object);\n  \n  if (keysA.length !== keysB.length) return false;\n  \n  for (const key of keysA) {\n    if (!Object.prototype.hasOwnProperty.call(b, key)) return false;\n    if ((a as Record<string, unknown>)[key] !== (b as Record<string, unknown>)[key]) return false;\n  }\n  \n  return true;\n}\n\n// Strict deep equal (considers property order and more strict type checking)","approach":"Shallow","timeComplexity":"O(k)","spaceComplexity":"O(1)","isOptimal":true,"type":"function"},{"name":"deepEqualJSON","tabName":"JSON","code":"export function deepEqualJSON(a: unknown, b: unknown): boolean {\n  try {\n    return JSON.stringify(a) === JSON.stringify(b);\n  } catch {\n    return false;\n  }\n}\n\n// Utility metadata","approach":"JSON","timeComplexity":"O(n)","spaceComplexity":"O(n)","isOptimal":false,"type":"function"}]}