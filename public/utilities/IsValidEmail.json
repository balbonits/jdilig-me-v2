{"name":"IsValidEmail","slug":"IsValidEmail","metadata":{"title":"IsValidEmail Function","description":"Comprehensive email validation with multiple validation strategies from basic to RFC-compliant patterns","category":"Validation","concepts":["regular expressions","string validation","RFC standards","input validation"],"timeComplexity":"O(n) where n is email length","spaceComplexity":"O(1) constant space","difficulty":"Easy","examples":["isValidEmail('user@example.com') → true"],"performanceNotes":"- Time: O(n) where n is email string length\n - Space: O(1) constant space"},"examples":[{"input":"'user@example.com'","output":"true","description":"Basic email validation","code":"// Valid emails\nisValidEmail('user@example.com');           // true\nisValidEmail('test.email@domain.org');      // true\nisValidEmail('user+tag@example.co.uk');     // true\n\n// Invalid emails\nisValidEmail('');                           // false\nisValidEmail('user@');                      // false\nisValidEmail('@domain.com');                // false\nisValidEmail('user.domain.com');            // false\nisValidEmail('user@domain');                // false"},{"input":"form input","output":"validation result","description":"Form validation with email checking","code":"interface LoginForm {\n  email: string;\n  password: string;\n}\n\nfunction validateLoginForm(form: LoginForm): string[] {\n  const errors: string[] = [];\n  \n  if (!isValidEmail(form.email)) {\n    errors.push('Please enter a valid email address');\n  }\n  \n  if (form.password.length < 8) {\n    errors.push('Password must be at least 8 characters');\n  }\n  \n  return errors;\n}\n\nconst form = { email: 'invalid-email', password: '123' };\nconst errors = validateLoginForm(form);\n// ['Please enter a valid email address', 'Password must be at least 8 characters']"},{"input":"'user@invalid'","output":"detailed errors","description":"Detailed email validation with error reporting","code":"const result = validateEmailDetailed('user@invalid');\nconsole.log(result);\n// {\n//   isValid: false,\n//   errors: ['Domain must contain at least one dot']\n// }\n\nconst result2 = validateEmailDetailed('  user@example.com  ');\nconsole.log(result2);\n// {\n//   isValid: false,\n//   errors: ['Email contains leading or trailing whitespace']\n// }\n\n// Use in user interfaces\nfunction displayEmailErrors(email: string) {\n  const validation = validateEmailDetailed(email);\n  if (!validation.isValid) {\n    return validation.errors.join(', ');\n  }\n  return 'Email is valid';\n}"},{"input":"email array","output":"filtered valid emails","description":"Filter valid emails from a list","code":"const emailList = [\n  'user@example.com',\n  'invalid-email',\n  'test@domain.org',\n  'another@invalid',\n  'valid@company.co.uk'\n];\n\n// Filter valid emails\nconst validEmails = emailList.filter(isValidEmail);\nconsole.log(validEmails);\n// ['user@example.com', 'test@domain.org', 'valid@company.co.uk']\n\n// Count valid vs invalid\nconst validCount = emailList.filter(isValidEmail).length;\nconst invalidCount = emailList.length - validCount;\nconsole.log(`Valid: ${validCount}, Invalid: ${invalidCount}`);\n// 'Valid: 3, Invalid: 2'\n\n// Group by validity\nconst grouped = emailList.reduce((acc, email) => {\n  const key = isValidEmail(email) ? 'valid' : 'invalid';\n  acc[key] = acc[key] || [];\n  acc[key].push(email);\n  return acc;\n}, {} as Record<string, string[]>);"}],"code":"import type { UtilityMetadata, UtilityExample } from '@/interfaces/utilities';\nimport type { SolutionMetadata } from '@/interfaces/shared';\n\n/**\n * IsValidEmail Utility Implementation\n * \n * DESCRIPTION:\n * Validates email addresses using different validation strategies from basic regex\n * to comprehensive RFC-compliant validation. Essential for form validation and user input.\n * \n * ENHANCED METADATA:\n * - Difficulty: Easy to Medium (regex patterns and validation logic)\n * - Solution Type: function (validation utility with regex patterns)\n * - Time Complexity: O(n) where n is email length\n * - Space Complexity: O(1) constant space usage\n * - Concepts: Regular expressions, String validation, RFC standards, Input validation\n * - Category: Data validation utility\n * \n * EXAMPLE:\n * isValidEmail('user@example.com') → true\n * \n * CONCEPTS:\n * - Regular expression patterns\n * - String manipulation and validation\n * - RFC 5322 email standards\n * - Input sanitization\n * \n * PERFORMANCE:\n * - Time: O(n) where n is email string length\n * - Space: O(1) constant space\n * \n * Multiple implementations included to show different validation approaches.\n */\n\n// Basic email validation (most common use case)\nexport function isValidEmail(email: string): boolean {\n  if (typeof email !== 'string') return false;\n  if (email.length === 0 || email.length > 320) return false; // RFC limit\n  \n  // Basic regex pattern that covers most real-world cases\n  const basicPattern = /^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$/;\n  return basicPattern.test(email.trim());\n}\n\n// Comprehensive email validation\nexport function isValidEmailComprehensive(email: string): boolean {\n  if (typeof email !== 'string') return false;\n  if (email.length === 0 || email.length > 320) return false;\n  \n  const trimmedEmail = email.trim();\n  \n  // Check for basic structure\n  const atCount = (trimmedEmail.match(/@/g) || []).length;\n  if (atCount !== 1) return false;\n  \n  const [localPart, domainPart] = trimmedEmail.split('@');\n  \n  // Validate local part (before @)\n  if (!localPart || localPart.length === 0 || localPart.length > 64) return false;\n  if (localPart.startsWith('.') || localPart.endsWith('.')) return false;\n  if (localPart.includes('..')) return false;\n  \n  // Validate domain part (after @)\n  if (!domainPart || domainPart.length === 0 || domainPart.length > 255) return false;\n  if (domainPart.startsWith('.') || domainPart.endsWith('.')) return false;\n  if (domainPart.startsWith('-') || domainPart.endsWith('-')) return false;\n  \n  // More comprehensive pattern\n  const comprehensivePattern = /^[a-zA-Z0-9!#$%&'*+/=?^_`{|}~-]+(?:\\.[a-zA-Z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-zA-Z0-9](?:[a-zA-Z0-9-]*[a-zA-Z0-9])?\\.)+[a-zA-Z0-9](?:[a-zA-Z0-9-]*[a-zA-Z0-9])?$/;\n  return comprehensivePattern.test(trimmedEmail);\n}\n\n// Strict RFC 5322 compliant validation (simplified)\nexport function isValidEmailRFC(email: string): boolean {\n  if (typeof email !== 'string') return false;\n  if (email.length === 0 || email.length > 320) return false;\n  \n  // Simplified RFC 5322 pattern (actual RFC is extremely complex)\n  const rfcPattern = /^[a-zA-Z0-9!#$%&'*+/=?^_`{|}~-]+(?:\\.[a-zA-Z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-zA-Z0-9](?:[a-zA-Z0-9-]*[a-zA-Z0-9])?\\.)+[a-zA-Z0-9](?:[a-zA-Z0-9-]*[a-zA-Z0-9])?$/;\n  return rfcPattern.test(email.trim());\n}\n\n// Simple email validation (very permissive)\nexport function isValidEmailSimple(email: string): boolean {\n  if (typeof email !== 'string') return false;\n  if (email.length === 0) return false;\n  \n  // Very basic pattern for quick validation\n  const simplePattern = /^.+@.+\\..+$/;\n  return simplePattern.test(email.trim());\n}\n\n// Email validation with detailed error information\nexport interface EmailValidationResult {\n  isValid: boolean;\n  errors: string[];\n}\n\nexport function validateEmailDetailed(email: string): EmailValidationResult {\n  const errors: string[] = [];\n  \n  if (typeof email !== 'string') {\n    errors.push('Email must be a string');\n    return { isValid: false, errors };\n  }\n  \n  if (email.length === 0) {\n    errors.push('Email cannot be empty');\n    return { isValid: false, errors };\n  }\n  \n  if (email.length > 320) {\n    errors.push('Email is too long (max 320 characters)');\n  }\n  \n  const trimmedEmail = email.trim();\n  \n  if (trimmedEmail !== email) {\n    errors.push('Email contains leading or trailing whitespace');\n  }\n  \n  const atCount = (trimmedEmail.match(/@/g) || []).length;\n  if (atCount === 0) {\n    errors.push('Email must contain @ symbol');\n  } else if (atCount > 1) {\n    errors.push('Email contains multiple @ symbols');\n  }\n  \n  if (atCount === 1) {\n    const [localPart, domainPart] = trimmedEmail.split('@');\n    \n    if (!localPart) {\n      errors.push('Email missing local part (before @)');\n    } else {\n      if (localPart.length > 64) {\n        errors.push('Local part is too long (max 64 characters)');\n      }\n      if (localPart.startsWith('.') || localPart.endsWith('.')) {\n        errors.push('Local part cannot start or end with a dot');\n      }\n      if (localPart.includes('..')) {\n        errors.push('Local part cannot contain consecutive dots');\n      }\n    }\n    \n    if (!domainPart) {\n      errors.push('Email missing domain part (after @)');\n    } else {\n      if (domainPart.length > 255) {\n        errors.push('Domain part is too long (max 255 characters)');\n      }\n      if (!domainPart.includes('.')) {\n        errors.push('Domain must contain at least one dot');\n      }\n      if (domainPart.startsWith('.') || domainPart.endsWith('.')) {\n        errors.push('Domain cannot start or end with a dot');\n      }\n      if (domainPart.startsWith('-') || domainPart.endsWith('-')) {\n        errors.push('Domain cannot start or end with a hyphen');\n      }\n    }\n  }\n  \n  return { isValid: errors.length === 0, errors };\n}\n\n// Utility metadata\nexport const metadata: UtilityMetadata = {\n  title: \"IsValidEmail Function\",\n  description: \"Comprehensive email validation with multiple validation strategies from basic to RFC-compliant patterns\",\n  category: \"Validation\",\n  concepts: [\"regular expressions\", \"string validation\", \"RFC standards\", \"input validation\"],\n  timeComplexity: \"O(n) where n is email length\",\n  spaceComplexity: \"O(1) constant space\",\n  difficulty: \"Easy\"\n};\n\nexport const solutions: SolutionMetadata[] = [\n  {\n    name: \"isValidEmail\",\n    tabName: \"Basic\",\n    approach: \"Standard email validation for most use cases\",\n    timeComplexity: \"O(n)\",\n    spaceComplexity: \"O(1)\",\n    isOptimal: true,\n    type: \"function\"\n  },\n  {\n    name: \"isValidEmailComprehensive\",\n    tabName: \"Comprehensive\",\n    approach: \"Thorough validation with multiple checks\",\n    timeComplexity: \"O(n)\",\n    spaceComplexity: \"O(1)\",\n    isOptimal: true,\n    type: \"function\"\n  },\n  {\n    name: \"isValidEmailRFC\",\n    tabName: \"RFC\",\n    approach: \"RFC 5322 compliant validation (simplified)\",\n    timeComplexity: \"O(n)\",\n    spaceComplexity: \"O(1)\",\n    isOptimal: false,\n    type: \"function\"\n  },\n  {\n    name: \"validateEmailDetailed\",\n    tabName: \"Detailed\",\n    approach: \"Validation with detailed error reporting\",\n    timeComplexity: \"O(n)\",\n    spaceComplexity: \"O(k)\",\n    isOptimal: false,\n    type: \"function\"\n  }\n];\n\n// Example use cases\nexport const examples: UtilityExample[] = [\n  {\n    input: \"'user@example.com'\",\n    output: \"true\",\n    description: \"Basic email validation\",\n    code: `// Valid emails\nisValidEmail('user@example.com');           // true\nisValidEmail('test.email@domain.org');      // true\nisValidEmail('user+tag@example.co.uk');     // true\n\n// Invalid emails\nisValidEmail('');                           // false\nisValidEmail('user@');                      // false\nisValidEmail('@domain.com');                // false\nisValidEmail('user.domain.com');            // false\nisValidEmail('user@domain');                // false`\n  },\n  {\n    input: \"form input\",\n    output: \"validation result\",\n    description: \"Form validation with email checking\",\n    code: `interface LoginForm {\n  email: string;\n  password: string;\n}\n\nfunction validateLoginForm(form: LoginForm): string[] {\n  const errors: string[] = [];\n  \n  if (!isValidEmail(form.email)) {\n    errors.push('Please enter a valid email address');\n  }\n  \n  if (form.password.length < 8) {\n    errors.push('Password must be at least 8 characters');\n  }\n  \n  return errors;\n}\n\nconst form = { email: 'invalid-email', password: '123' };\nconst errors = validateLoginForm(form);\n// ['Please enter a valid email address', 'Password must be at least 8 characters']`\n  },\n  {\n    input: \"'user@invalid'\",\n    output: \"detailed errors\",\n    description: \"Detailed email validation with error reporting\",\n    code: `const result = validateEmailDetailed('user@invalid');\nconsole.log(result);\n// {\n//   isValid: false,\n//   errors: ['Domain must contain at least one dot']\n// }\n\nconst result2 = validateEmailDetailed('  user@example.com  ');\nconsole.log(result2);\n// {\n//   isValid: false,\n//   errors: ['Email contains leading or trailing whitespace']\n// }\n\n// Use in user interfaces\nfunction displayEmailErrors(email: string) {\n  const validation = validateEmailDetailed(email);\n  if (!validation.isValid) {\n    return validation.errors.join(', ');\n  }\n  return 'Email is valid';\n}`\n  },\n  {\n    input: \"email array\",\n    output: \"filtered valid emails\",\n    description: \"Filter valid emails from a list\",\n    code: `const emailList = [\n  'user@example.com',\n  'invalid-email',\n  'test@domain.org',\n  'another@invalid',\n  'valid@company.co.uk'\n];\n\n// Filter valid emails\nconst validEmails = emailList.filter(isValidEmail);\nconsole.log(validEmails);\n// ['user@example.com', 'test@domain.org', 'valid@company.co.uk']\n\n// Count valid vs invalid\nconst validCount = emailList.filter(isValidEmail).length;\nconst invalidCount = emailList.length - validCount;\nconsole.log(\\`Valid: \\${validCount}, Invalid: \\${invalidCount}\\`);\n// 'Valid: 3, Invalid: 2'\n\n// Group by validity\nconst grouped = emailList.reduce((acc, email) => {\n  const key = isValidEmail(email) ? 'valid' : 'invalid';\n  acc[key] = acc[key] || [];\n  acc[key].push(email);\n  return acc;\n}, {} as Record<string, string[]>);`\n  }\n];\n\n// Default export for easy importing\nconst utilityModule = {\n  isValidEmail,\n  isValidEmailComprehensive,\n  isValidEmailRFC,\n  isValidEmailSimple,\n  validateEmailDetailed,\n  metadata,\n  solutions,\n  examples\n};\n\nexport default utilityModule;","functions":["isValidEmail","isValidEmailComprehensive","isValidEmailRFC","isValidEmailSimple","validateEmailDetailed"],"solutions":[{"name":"isValidEmail","tabName":"Basic","code":"export function isValidEmail(email: string): boolean {\n  if (typeof email !== 'string') return false;\n  if (email.length === 0 || email.length > 320) return false; // RFC limit\n  \n  // Basic regex pattern that covers most real-world cases\n  const basicPattern = /^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$/;\n  return basicPattern.test(email.trim());\n}\n\n// Comprehensive email validation","approach":"Basic","timeComplexity":"O(n)","spaceComplexity":"O(1)","isOptimal":true,"type":"function"},{"name":"isValidEmailComprehensive","tabName":"Comprehensive","code":"export function isValidEmailComprehensive(email: string): boolean {\n  if (typeof email !== 'string') return false;\n  if (email.length === 0 || email.length > 320) return false;\n  \n  const trimmedEmail = email.trim();\n  \n  // Check for basic structure\n  const atCount = (trimmedEmail.match(/@/g) || []).length;\n  if (atCount !== 1) return false;\n  \n  const [localPart, domainPart] = trimmedEmail.split('@');\n  \n  // Validate local part (before @)\n  if (!localPart || localPart.length === 0 || localPart.length > 64) return false;\n  if (localPart.startsWith('.') || localPart.endsWith('.')) return false;\n  if (localPart.includes('..')) return false;\n  \n  // Validate domain part (after @)\n  if (!domainPart || domainPart.length === 0 || domainPart.length > 255) return false;\n  if (domainPart.startsWith('.') || domainPart.endsWith('.')) return false;\n  if (domainPart.startsWith('-') || domainPart.endsWith('-')) return false;\n  \n  // More comprehensive pattern\n  const comprehensivePattern = /^[a-zA-Z0-9!#$%&'*+/=?^_`{|}~-]+(?:\\.[a-zA-Z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-zA-Z0-9](?:[a-zA-Z0-9-]*[a-zA-Z0-9])?\\.)+[a-zA-Z0-9](?:[a-zA-Z0-9-]*[a-zA-Z0-9])?$/;\n  return comprehensivePattern.test(trimmedEmail);\n}\n\n// Strict RFC 5322 compliant validation (simplified)","approach":"Comprehensive","timeComplexity":"O(n)","spaceComplexity":"O(1)","isOptimal":true,"type":"function"},{"name":"isValidEmailRFC","tabName":"RFC","code":"export function isValidEmailRFC(email: string): boolean {\n  if (typeof email !== 'string') return false;\n  if (email.length === 0 || email.length > 320) return false;\n  \n  // Simplified RFC 5322 pattern (actual RFC is extremely complex)\n  const rfcPattern = /^[a-zA-Z0-9!#$%&'*+/=?^_`{|}~-]+(?:\\.[a-zA-Z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-zA-Z0-9](?:[a-zA-Z0-9-]*[a-zA-Z0-9])?\\.)+[a-zA-Z0-9](?:[a-zA-Z0-9-]*[a-zA-Z0-9])?$/;\n  return rfcPattern.test(email.trim());\n}\n\n// Simple email validation (very permissive)","approach":"RFC","timeComplexity":"O(n)","spaceComplexity":"O(1)","isOptimal":false,"type":"function"},{"name":"validateEmailDetailed","tabName":"Detailed","code":"export function validateEmailDetailed(email: string): EmailValidationResult {\n  const errors: string[] = [];\n  \n  if (typeof email !== 'string') {\n    errors.push('Email must be a string');\n    return { isValid: false, errors };\n  }\n  \n  if (email.length === 0) {\n    errors.push('Email cannot be empty');\n    return { isValid: false, errors };\n  }\n  \n  if (email.length > 320) {\n    errors.push('Email is too long (max 320 characters)');\n  }\n  \n  const trimmedEmail = email.trim();\n  \n  if (trimmedEmail !== email) {\n    errors.push('Email contains leading or trailing whitespace');\n  }\n  \n  const atCount = (trimmedEmail.match(/@/g) || []).length;\n  if (atCount === 0) {\n    errors.push('Email must contain @ symbol');\n  } else if (atCount > 1) {\n    errors.push('Email contains multiple @ symbols');\n  }\n  \n  if (atCount === 1) {\n    const [localPart, domainPart] = trimmedEmail.split('@');\n    \n    if (!localPart) {\n      errors.push('Email missing local part (before @)');\n    } else {\n      if (localPart.length > 64) {\n        errors.push('Local part is too long (max 64 characters)');\n      }\n      if (localPart.startsWith('.') || localPart.endsWith('.')) {\n        errors.push('Local part cannot start or end with a dot');\n      }\n      if (localPart.includes('..')) {\n        errors.push('Local part cannot contain consecutive dots');\n      }\n    }\n    \n    if (!domainPart) {\n      errors.push('Email missing domain part (after @)');\n    } else {\n      if (domainPart.length > 255) {\n        errors.push('Domain part is too long (max 255 characters)');\n      }\n      if (!domainPart.includes('.')) {\n        errors.push('Domain must contain at least one dot');\n      }\n      if (domainPart.startsWith('.') || domainPart.endsWith('.')) {\n        errors.push('Domain cannot start or end with a dot');\n      }\n      if (domainPart.startsWith('-') || domainPart.endsWith('-')) {\n        errors.push('Domain cannot start or end with a hyphen');\n      }\n    }\n  }\n  \n  return { isValid: errors.length === 0, errors };\n}\n\n// Utility metadata","approach":"Detailed","timeComplexity":"O(n)","spaceComplexity":"O(k)","isOptimal":false,"type":"function"}]}