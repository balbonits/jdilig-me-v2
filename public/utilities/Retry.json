{"name":"Retry","slug":"Retry","metadata":{"title":"Retry Function","description":"Automatically retries failed operations with configurable backoff strategies, essential for handling unreliable network operations","category":"Reliability","concepts":["async/await","error handling","exponential backoff","promises"],"timeComplexity":"O(n) where n is retry attempts","spaceComplexity":"O(1) for operation state","difficulty":"Medium","examples":["retry(apiCall, { attempts: 3, delay: 1000 }) → Retries failed API calls"],"performanceNotes":"- Time: O(n) where n is retry attempts\n - Space: O(1) for operation state"},"examples":[{"input":"fetch('/api/data')","output":"response data","description":"Basic API retry with exponential backoff","code":"const fetchData = async () => {\n  const response = await fetch('/api/data');\n  if (!response.ok) throw new Error('Network error');\n  return response.json();\n};\n\nconst data = await retry(fetchData, {\n  attempts: 3,\n  delay: 1000,\n  exponentialBackoff: true,\n  maxDelay: 10000\n});\n\n// Retries: 1s, 2s, 4s delays on failure"},{"input":"unreliableOperation()","output":"success result","description":"Conditional retry with custom logic","code":"const processPayment = async (amount: number) => {\n  // Simulate payment processing\n  if (Math.random() < 0.7) throw new Error('Payment gateway timeout');\n  return { transactionId: Date.now(), amount };\n};\n\nconst payment = await retry(() => processPayment(100), {\n  attempts: 5,\n  delay: 2000,\n  shouldRetry: (error, attempt) => {\n    // Only retry on timeout errors\n    return error.message.includes('timeout');\n  },\n  onRetry: (error, attempt) => {\n    console.log(`Payment attempt ${attempt} failed: ${error.message}`);\n  }\n});"},{"input":"service.call()","output":"protected result","description":"Circuit breaker pattern for system protection","code":"const circuitBreaker = new RetryWithCircuitBreaker(3, 30000);\n\nconst callExternalService = async () => {\n  const response = await fetch('/external-api');\n  if (!response.ok) throw new Error('Service unavailable');\n  return response.json();\n};\n\ntry {\n  const result = await circuitBreaker.execute(callExternalService, {\n    attempts: 2,\n    delay: 1000\n  });\n} catch (error) {\n  // Circuit breaker may be OPEN after repeated failures\n  console.log('Service call failed or circuit breaker is open');\n}"},{"input":"parseJSON(data)","output":"parsed object","description":"Synchronous operation retry","code":"const parseWithRetry = (jsonString: string) => {\n  // Simulate flaky parsing operation\n  if (Math.random() < 0.3) throw new Error('Parse error');\n  return JSON.parse(jsonString);\n};\n\nconst result = retrySync(\n  () => parseWithRetry('{\"key\": \"value\"}'),\n  3,\n  (error, attempt) => error.message === 'Parse error'\n);\n\n// Retries immediately without delays for sync operations"}],"code":"import type { UtilityMetadata, UtilityExample } from '@/interfaces/utilities';\nimport type { SolutionMetadata } from '@/interfaces/shared';\n\n/**\n * Retry Utility Implementation\n * \n * DESCRIPTION:\n * Automatically retries failed operations with configurable backoff strategies.\n * Essential for handling network requests, API calls, and unreliable operations.\n * \n * ENHANCED METADATA:\n * - Difficulty: Medium (async patterns and error handling)\n * - Solution Type: function (async operation wrapper with retry logic)\n * - Time Complexity: O(n) where n is number of retry attempts\n * - Space Complexity: O(1) for operation state\n * - Concepts: Async/await, Error handling, Exponential backoff, Promises\n * - Category: Reliability and error handling utility\n * \n * EXAMPLE:\n * retry(apiCall, { attempts: 3, delay: 1000 }) → Retries failed API calls\n * \n * CONCEPTS:\n * - Async/await patterns\n * - Error handling strategies\n * - Exponential backoff algorithms\n * - Promise-based operations\n * - Reliability patterns\n * \n * PERFORMANCE:\n * - Time: O(n) where n is retry attempts\n * - Space: O(1) for operation state\n * \n * Multiple implementations included to show different retry strategies.\n */\n\nexport interface RetryOptions {\n  attempts?: number;\n  delay?: number;\n  exponentialBackoff?: boolean;\n  maxDelay?: number;\n  shouldRetry?: (error: Error, attempt: number) => boolean;\n  onRetry?: (error: Error, attempt: number) => void;\n}\n\n// Basic retry implementation\nexport async function retry<T>(\n  operation: () => Promise<T>,\n  options: RetryOptions = {}\n): Promise<T> {\n  const {\n    attempts = 3,\n    delay = 1000,\n    exponentialBackoff = false,\n    maxDelay = 30000,\n    shouldRetry = () => true,\n    onRetry\n  } = options;\n\n  if (typeof operation !== 'function') throw new Error(\"Operation must be a function\");\n  if (!Number.isInteger(attempts) || attempts < 1) throw new Error(\"Attempts must be a positive integer\");\n  if (!Number.isInteger(delay) || delay < 0) throw new Error(\"Delay must be a non-negative integer\");\n\n  let lastError: Error;\n\n  for (let attempt = 1; attempt <= attempts; attempt++) {\n    try {\n      return await operation();\n    } catch (error) {\n      lastError = error as Error;\n\n      if (attempt === attempts || !shouldRetry(lastError, attempt)) {\n        throw lastError;\n      }\n\n      onRetry?.(lastError, attempt);\n\n      const currentDelay = exponentialBackoff \n        ? Math.min(delay * Math.pow(2, attempt - 1), maxDelay)\n        : delay;\n\n      await sleep(currentDelay);\n    }\n  }\n\n  throw lastError!;\n}\n\n// Retry with jitter to prevent thundering herd\nexport async function retryWithJitter<T>(\n  operation: () => Promise<T>,\n  options: RetryOptions & { jitter?: boolean } = {}\n): Promise<T> {\n  const { jitter = true, ...retryOptions } = options;\n  \n  return retry(operation, {\n    ...retryOptions,\n    delay: jitter && retryOptions.delay \n      ? retryOptions.delay + Math.random() * 1000 \n      : retryOptions.delay\n  });\n}\n\n// Retry with circuit breaker pattern\nexport class RetryWithCircuitBreaker {\n  private failures = 0;\n  private lastFailureTime = 0;\n  private state: 'CLOSED' | 'OPEN' | 'HALF_OPEN' = 'CLOSED';\n\n  constructor(\n    private failureThreshold = 5,\n    private recoveryTimeout = 60000\n  ) {}\n\n  async execute<T>(\n    operation: () => Promise<T>,\n    options: RetryOptions = {}\n  ): Promise<T> {\n    if (this.state === 'OPEN') {\n      if (Date.now() - this.lastFailureTime < this.recoveryTimeout) {\n        throw new Error('Circuit breaker is OPEN');\n      }\n      this.state = 'HALF_OPEN';\n    }\n\n    try {\n      const result = await retry(operation, {\n        ...options,\n        shouldRetry: (error, attempt) => {\n          if (this.state === 'HALF_OPEN' && attempt === 1) {\n            return false; // Fail fast in half-open state\n          }\n          return options.shouldRetry?.(error, attempt) ?? true;\n        }\n      });\n\n      // Success resets the circuit breaker\n      this.failures = 0;\n      this.state = 'CLOSED';\n      return result;\n\n    } catch (error) {\n      this.failures++;\n      this.lastFailureTime = Date.now();\n\n      if (this.failures >= this.failureThreshold) {\n        this.state = 'OPEN';\n      }\n\n      throw error;\n    }\n  }\n}\n\n// Simple retry for synchronous operations\nexport function retrySync<T>(\n  operation: () => T,\n  attempts: number = 3,\n  shouldRetry: (error: Error, attempt: number) => boolean = () => true\n): T {\n  if (typeof operation !== 'function') throw new Error(\"Operation must be a function\");\n  if (!Number.isInteger(attempts) || attempts < 1) throw new Error(\"Attempts must be a positive integer\");\n\n  let lastError: Error;\n\n  for (let attempt = 1; attempt <= attempts; attempt++) {\n    try {\n      return operation();\n    } catch (error) {\n      lastError = error as Error;\n\n      if (attempt === attempts || !shouldRetry(lastError, attempt)) {\n        throw lastError;\n      }\n    }\n  }\n\n  throw lastError!;\n}\n\n// Helper function for delay\nfunction sleep(ms: number): Promise<void> {\n  return new Promise(resolve => setTimeout(resolve, ms));\n}\n\n// Utility metadata\nexport const metadata: UtilityMetadata = {\n  title: \"Retry Function\",\n  description: \"Automatically retries failed operations with configurable backoff strategies, essential for handling unreliable network operations\",\n  category: \"Reliability\",\n  concepts: [\"async/await\", \"error handling\", \"exponential backoff\", \"promises\"],\n  timeComplexity: \"O(n) where n is retry attempts\",\n  spaceComplexity: \"O(1) for operation state\",\n  difficulty: \"Medium\"\n};\n\nexport const solutions: SolutionMetadata[] = [\n  {\n    name: \"retry\",\n    tabName: \"Basic\",\n    approach: \"Configurable retry with exponential backoff support\",\n    timeComplexity: \"O(n)\",\n    spaceComplexity: \"O(1)\",\n    isOptimal: true,\n    type: \"function\"\n  },\n  {\n    name: \"retryWithJitter\",\n    tabName: \"Jitter\",\n    approach: \"Retry with jitter to prevent thundering herd problem\",\n    timeComplexity: \"O(n)\",\n    spaceComplexity: \"O(1)\",\n    isOptimal: true,\n    type: \"function\"\n  },\n  {\n    name: \"RetryWithCircuitBreaker\",\n    tabName: \"Circuit Breaker\",\n    approach: \"Retry with circuit breaker pattern for system protection\",\n    timeComplexity: \"O(n)\",\n    spaceComplexity: \"O(1)\",\n    isOptimal: false,\n    type: \"class\"\n  },\n  {\n    name: \"retrySync\",\n    tabName: \"Synchronous\",\n    approach: \"Simple retry for synchronous operations\",\n    timeComplexity: \"O(n)\",\n    spaceComplexity: \"O(1)\",\n    isOptimal: true,\n    type: \"function\"\n  }\n];\n\n// Example use cases\nexport const examples: UtilityExample[] = [\n  {\n    input: \"fetch('/api/data')\",\n    output: \"response data\",\n    description: \"Basic API retry with exponential backoff\",\n    code: `const fetchData = async () => {\n  const response = await fetch('/api/data');\n  if (!response.ok) throw new Error('Network error');\n  return response.json();\n};\n\nconst data = await retry(fetchData, {\n  attempts: 3,\n  delay: 1000,\n  exponentialBackoff: true,\n  maxDelay: 10000\n});\n\n// Retries: 1s, 2s, 4s delays on failure`\n  },\n  {\n    input: \"unreliableOperation()\",\n    output: \"success result\",\n    description: \"Conditional retry with custom logic\",\n    code: `const processPayment = async (amount: number) => {\n  // Simulate payment processing\n  if (Math.random() < 0.7) throw new Error('Payment gateway timeout');\n  return { transactionId: Date.now(), amount };\n};\n\nconst payment = await retry(() => processPayment(100), {\n  attempts: 5,\n  delay: 2000,\n  shouldRetry: (error, attempt) => {\n    // Only retry on timeout errors\n    return error.message.includes('timeout');\n  },\n  onRetry: (error, attempt) => {\n    console.log(\\`Payment attempt \\${attempt} failed: \\${error.message}\\`);\n  }\n});`\n  },\n  {\n    input: \"service.call()\",\n    output: \"protected result\",\n    description: \"Circuit breaker pattern for system protection\",\n    code: `const circuitBreaker = new RetryWithCircuitBreaker(3, 30000);\n\nconst callExternalService = async () => {\n  const response = await fetch('/external-api');\n  if (!response.ok) throw new Error('Service unavailable');\n  return response.json();\n};\n\ntry {\n  const result = await circuitBreaker.execute(callExternalService, {\n    attempts: 2,\n    delay: 1000\n  });\n} catch (error) {\n  // Circuit breaker may be OPEN after repeated failures\n  console.log('Service call failed or circuit breaker is open');\n}`\n  },\n  {\n    input: \"parseJSON(data)\",\n    output: \"parsed object\",\n    description: \"Synchronous operation retry\",\n    code: `const parseWithRetry = (jsonString: string) => {\n  // Simulate flaky parsing operation\n  if (Math.random() < 0.3) throw new Error('Parse error');\n  return JSON.parse(jsonString);\n};\n\nconst result = retrySync(\n  () => parseWithRetry('{\"key\": \"value\"}'),\n  3,\n  (error, attempt) => error.message === 'Parse error'\n);\n\n// Retries immediately without delays for sync operations`\n  }\n];\n\n// Default export for easy importing\nconst utilityModule = {\n  retry,\n  retryWithJitter,\n  RetryWithCircuitBreaker,\n  retrySync,\n  metadata,\n  solutions,\n  examples\n};\n\nexport default utilityModule;","functions":["RetryWithCircuitBreaker","retry","retryWithJitter","retrySync"],"solutions":[{"name":"retry","tabName":"Basic","code":"export function retrySync<T>(\n  operation: () => T,\n  attempts: number = 3,\n  shouldRetry: (error: Error, attempt: number) => boolean = () => true\n): T {\n  if (typeof operation !== 'function') throw new Error(\"Operation must be a function\");\n  if (!Number.isInteger(attempts) || attempts < 1) throw new Error(\"Attempts must be a positive integer\");\n\n  let lastError: Error;\n\n  for (let attempt = 1; attempt <= attempts; attempt++) {\n    try {\n      return operation();\n    } catch (error) {\n      lastError = error as Error;\n\n      if (attempt === attempts || !shouldRetry(lastError, attempt)) {\n        throw lastError;\n      }\n    }\n  }\n\n  throw lastError!;\n}\n\n// Helper function for delay\nfunction sleep(ms: number): Promise<void> {\n  return new Promise(resolve => setTimeout(resolve, ms));\n}\n\n// Utility metadata","approach":"Basic","timeComplexity":"O(n)","spaceComplexity":"O(1)","isOptimal":true,"type":"function"},{"name":"retryWithJitter","tabName":"Jitter","code":"","approach":"Jitter","timeComplexity":"O(n)","spaceComplexity":"O(1)","isOptimal":true,"type":"function"},{"name":"RetryWithCircuitBreaker","tabName":"Circuit Breaker","code":"","approach":"Circuit Breaker","timeComplexity":"O(n)","spaceComplexity":"O(1)","isOptimal":false,"type":"class"},{"name":"retrySync","tabName":"Synchronous","code":"export function retrySync<T>(\n  operation: () => T,\n  attempts: number = 3,\n  shouldRetry: (error: Error, attempt: number) => boolean = () => true\n): T {\n  if (typeof operation !== 'function') throw new Error(\"Operation must be a function\");\n  if (!Number.isInteger(attempts) || attempts < 1) throw new Error(\"Attempts must be a positive integer\");\n\n  let lastError: Error;\n\n  for (let attempt = 1; attempt <= attempts; attempt++) {\n    try {\n      return operation();\n    } catch (error) {\n      lastError = error as Error;\n\n      if (attempt === attempts || !shouldRetry(lastError, attempt)) {\n        throw lastError;\n      }\n    }\n  }\n\n  throw lastError!;\n}\n\n// Helper function for delay\nfunction sleep(ms: number): Promise<void> {\n  return new Promise(resolve => setTimeout(resolve, ms));\n}\n\n// Utility metadata","approach":"Synchronous","timeComplexity":"O(n)","spaceComplexity":"O(1)","isOptimal":true,"type":"function"}]}