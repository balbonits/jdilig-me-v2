{"name":"DeepClone","slug":"DeepClone","metadata":{"title":"DeepClone Function","description":"Creates deep copies of objects and arrays handling nested structures, circular references, and various JavaScript types","category":"Data Manipulation","concepts":["recursion","object traversal","type checking","memory management"],"timeComplexity":"O(n) where n is total properties/elements","spaceComplexity":"O(d) where d is maximum depth","difficulty":"Medium","examples":["deepClone({ a: { b: [1, 2] } }) → Independent copy with same structure"],"performanceNotes":"- Time: O(n) where n is total properties/elements\n - Space: O(d) where d is maximum nesting depth"},"examples":[{"input":"{ a: { b: [1, 2] } }","output":"independent copy","description":"Basic object and array deep cloning","code":"const original = {\n  user: {\n    name: 'John',\n    hobbies: ['reading', 'coding'],\n    settings: {\n      theme: 'dark',\n      notifications: true\n    }\n  }\n};\n\nconst cloned = deepClone(original);\n\n// Modify cloned object\ncloned.user.name = 'Jane';\ncloned.user.hobbies.push('gaming');\ncloned.user.settings.theme = 'light';\n\nconsole.log(original.user.name);           // 'John' (unchanged)\nconsole.log(original.user.hobbies);        // ['reading', 'coding'] (unchanged)\nconsole.log(original.user.settings.theme); // 'dark' (unchanged)\n\nconsole.log(cloned.user.name);             // 'Jane'\nconsole.log(cloned.user.hobbies);          // ['reading', 'coding', 'gaming']\nconsole.log(cloned.user.settings.theme);   // 'light'"},{"input":"circular reference","output":"safe clone","description":"Handling circular references safely","code":"const obj: any = { name: 'parent' };\nobj.child = { name: 'child', parent: obj };\n\n// This would cause infinite recursion with basic deepClone\n// const broken = deepClone(obj); // Stack overflow!\n\n// Safe cloning with circular reference detection\nconst safeClone = deepCloneWithCircularCheck(obj);\n\nconsole.log(safeClone.name);              // 'parent'\nconsole.log(safeClone.child.name);        // 'child'\nconsole.log(safeClone.child.parent === safeClone); // true (maintains reference)\n\n// Modify without affecting original\nsafeClone.child.name = 'modified child';\nconsole.log(obj.child.name);              // 'child' (unchanged)"},{"input":"complex data types","output":"type-preserved clone","description":"Cloning various JavaScript data types","code":"const complexObj = {\n  date: new Date('2024-01-01'),\n  regex: /test\\d+/gi,\n  set: new Set([1, 2, 3]),\n  map: new Map([['key1', 'value1'], ['key2', 'value2']]),\n  nested: {\n    array: [{ id: 1 }, { id: 2 }],\n    nullValue: null,\n    undefinedValue: undefined\n  }\n};\n\nconst cloned = deepClone(complexObj);\n\n// Verify types are preserved\nconsole.log(cloned.date instanceof Date);     // true\nconsole.log(cloned.regex instanceof RegExp);  // true\nconsole.log(cloned.set instanceof Set);       // true\nconsole.log(cloned.map instanceof Map);       // true\n\n// Verify independence\ncloned.set.add(4);\ncloned.map.set('key3', 'value3');\ncloned.nested.array.push({ id: 3 });\n\nconsole.log(complexObj.set.size);             // 3 (unchanged)\nconsole.log(complexObj.map.size);             // 2 (unchanged)\nconsole.log(complexObj.nested.array.length);  // 2 (unchanged)"},{"input":"performance comparison","output":"method selection","description":"Choosing the right cloning method for your use case","code":"const testData = {\n  users: Array.from({ length: 1000 }, (_, i) => ({\n    id: i,\n    name: `User ${i}`,\n    active: i % 2 === 0\n  }))\n};\n\n// JSON clone: Fastest but limited (no Dates, RegExp, etc.)\nconsole.time('JSON clone');\nconst jsonCloned = deepCloneJSON(testData);\nconsole.timeEnd('JSON clone');\n\n// Basic deep clone: Good balance of features and performance\nconsole.time('Deep clone');\nconst deepCloned = deepClone(testData);\nconsole.timeEnd('Deep clone');\n\n// Structured clone: Native browser/Node.js API (most robust)\nif (typeof structuredClone === 'function') {\n  console.time('Structured clone');\n  const structuredCloned = deepCloneStructured(testData);\n  console.timeEnd('Structured clone');\n}\n\n// Use JSON for simple objects without special types\n// Use deepClone for most cases with mixed data types\n// Use structuredClone for maximum robustness in modern environments"}],"code":"import type { UtilityMetadata, UtilityExample } from '@/interfaces/utilities';\nimport type { SolutionMetadata } from '@/interfaces/shared';\n\n/**\n * DeepClone Utility Implementation\n * \n * DESCRIPTION:\n * Creates deep copies of objects and arrays without external dependencies.\n * Handles nested structures, circular references, and various JavaScript types.\n * \n * ENHANCED METADATA:\n * - Difficulty: Medium (recursive patterns and type handling)\n * - Solution Type: function (recursive deep copying utility)\n * - Time Complexity: O(n) where n is total number of properties/elements\n * - Space Complexity: O(d) where d is maximum depth of nesting\n * - Concepts: Recursion, Object traversal, Type checking, Memory management\n * - Category: Data manipulation utility\n * \n * EXAMPLE:\n * deepClone({ a: { b: [1, 2] } }) → Independent copy with same structure\n * \n * CONCEPTS:\n * - Recursive algorithms\n * - Object and array traversal\n * - Type checking and handling\n * - Circular reference detection\n * - Memory management\n * \n * PERFORMANCE:\n * - Time: O(n) where n is total properties/elements\n * - Space: O(d) where d is maximum nesting depth\n * \n * Multiple implementations included to show different approaches.\n */\n\n// Basic deep clone implementation\nexport function deepClone<T>(obj: T): T {\n  // Handle primitive types and null\n  if (obj === null || typeof obj !== 'object') {\n    return obj;\n  }\n  \n  // Handle Date\n  if (obj instanceof Date) {\n    return new Date(obj.getTime()) as T;\n  }\n  \n  // Handle RegExp\n  if (obj instanceof RegExp) {\n    return new RegExp(obj.source, obj.flags) as T;\n  }\n  \n  // Handle Array\n  if (Array.isArray(obj)) {\n    return obj.map(item => deepClone(item)) as T;\n  }\n  \n  // Handle Set\n  if (obj instanceof Set) {\n    const clonedSet = new Set();\n    obj.forEach(value => clonedSet.add(deepClone(value)));\n    return clonedSet as T;\n  }\n  \n  // Handle Map\n  if (obj instanceof Map) {\n    const clonedMap = new Map();\n    obj.forEach((value, key) => clonedMap.set(deepClone(key), deepClone(value)));\n    return clonedMap as T;\n  }\n  \n  // Handle plain objects\n  if (obj.constructor === Object) {\n    const clonedObj = {} as T;\n    for (const key in obj) {\n      if (Object.prototype.hasOwnProperty.call(obj, key)) {\n        (clonedObj as Record<string, unknown>)[key] = deepClone((obj as Record<string, unknown>)[key]);\n      }\n    }\n    return clonedObj;\n  }\n  \n  // For other objects, return as-is (functions, classes, etc.)\n  return obj;\n}\n\n// Deep clone with circular reference detection\nexport function deepCloneWithCircularCheck<T>(obj: T, seen = new WeakMap()): T {\n  // Handle primitive types and null\n  if (obj === null || typeof obj !== 'object') {\n    return obj;\n  }\n  \n  // Check for circular reference\n  if (seen.has(obj as object)) {\n    return seen.get(obj as object);\n  }\n  \n  // Handle Date\n  if (obj instanceof Date) {\n    const cloned = new Date(obj.getTime()) as T;\n    seen.set(obj as object, cloned);\n    return cloned;\n  }\n  \n  // Handle RegExp\n  if (obj instanceof RegExp) {\n    const cloned = new RegExp(obj.source, obj.flags) as T;\n    seen.set(obj as object, cloned);\n    return cloned;\n  }\n  \n  // Handle Array\n  if (Array.isArray(obj)) {\n    const clonedArray: unknown[] = [];\n    seen.set(obj as object, clonedArray);\n    obj.forEach((item, index) => {\n      clonedArray[index] = deepCloneWithCircularCheck(item, seen);\n    });\n    return clonedArray as T;\n  }\n  \n  // Handle Set\n  if (obj instanceof Set) {\n    const clonedSet = new Set();\n    seen.set(obj as object, clonedSet);\n    obj.forEach(value => clonedSet.add(deepCloneWithCircularCheck(value, seen)));\n    return clonedSet as T;\n  }\n  \n  // Handle Map\n  if (obj instanceof Map) {\n    const clonedMap = new Map();\n    seen.set(obj as object, clonedMap);\n    obj.forEach((value, key) => {\n      clonedMap.set(\n        deepCloneWithCircularCheck(key, seen),\n        deepCloneWithCircularCheck(value, seen)\n      );\n    });\n    return clonedMap as T;\n  }\n  \n  // Handle plain objects\n  if (obj.constructor === Object) {\n    const clonedObj = {} as T;\n    seen.set(obj as object, clonedObj);\n    for (const key in obj) {\n      if (Object.prototype.hasOwnProperty.call(obj, key)) {\n        (clonedObj as Record<string, unknown>)[key] = deepCloneWithCircularCheck((obj as Record<string, unknown>)[key], seen);\n      }\n    }\n    return clonedObj;\n  }\n  \n  // For other objects, return as-is\n  seen.set(obj as object, obj);\n  return obj;\n}\n\n// JSON-based deep clone (fast but limited)\nexport function deepCloneJSON<T>(obj: T): T {\n  try {\n    return JSON.parse(JSON.stringify(obj));\n  } catch (error) {\n    throw new Error(`JSON deep clone failed: ${(error as Error).message}`);\n  }\n}\n\n// Structured clone API (modern browsers/Node.js)\nexport function deepCloneStructured<T>(obj: T): T {\n  if (typeof structuredClone === 'function') {\n    try {\n      return structuredClone(obj);\n    } catch (error) {\n      throw new Error(`Structured clone failed: ${(error as Error).message}`);\n    }\n  }\n  throw new Error('structuredClone is not available in this environment');\n}\n\n// Shallow clone for comparison\nexport function shallowClone<T>(obj: T): T {\n  if (obj === null || typeof obj !== 'object') {\n    return obj;\n  }\n  \n  if (Array.isArray(obj)) {\n    return [...obj] as T;\n  }\n  \n  if (obj instanceof Date) {\n    return new Date(obj) as T;\n  }\n  \n  if (obj instanceof Set) {\n    return new Set(obj) as T;\n  }\n  \n  if (obj instanceof Map) {\n    return new Map(obj) as T;\n  }\n  \n  return { ...obj } as T;\n}\n\n// Deep clone with custom options\nexport interface DeepCloneOptions {\n  includeNonEnumerable?: boolean;\n  includeSymbols?: boolean;\n  maxDepth?: number;\n  customCloners?: Map<unknown, (obj: unknown) => unknown>;\n}\n\nexport function deepCloneCustom<T>(obj: T, options: DeepCloneOptions = {}, depth = 0): T {\n  const { \n    includeNonEnumerable = false, \n    includeSymbols = false, \n    maxDepth = 100,\n    customCloners = new Map()\n  } = options;\n  \n  // Check max depth\n  if (depth > maxDepth) {\n    throw new Error(`Maximum cloning depth (${maxDepth}) exceeded`);\n  }\n  \n  // Handle primitive types and null\n  if (obj === null || typeof obj !== 'object') {\n    return obj;\n  }\n  \n  // Check for custom cloner\n  const constructor = obj.constructor;\n  if (customCloners.has(constructor)) {\n    return customCloners.get(constructor)(obj);\n  }\n  \n  // Handle built-in types\n  if (obj instanceof Date) return new Date(obj.getTime()) as T;\n  if (obj instanceof RegExp) return new RegExp(obj.source, obj.flags) as T;\n  \n  // Handle Array\n  if (Array.isArray(obj)) {\n    return obj.map(item => deepCloneCustom(item, options, depth + 1)) as T;\n  }\n  \n  // Handle Set\n  if (obj instanceof Set) {\n    const clonedSet = new Set();\n    obj.forEach(value => clonedSet.add(deepCloneCustom(value, options, depth + 1)));\n    return clonedSet as T;\n  }\n  \n  // Handle Map\n  if (obj instanceof Map) {\n    const clonedMap = new Map();\n    obj.forEach((value, key) => {\n      clonedMap.set(\n        deepCloneCustom(key, options, depth + 1),\n        deepCloneCustom(value, options, depth + 1)\n      );\n    });\n    return clonedMap as T;\n  }\n  \n  // Handle objects\n  const clonedObj = {} as T;\n  const keys = includeNonEnumerable \n    ? Object.getOwnPropertyNames(obj)\n    : Object.keys(obj);\n    \n  keys.forEach(key => {\n    (clonedObj as Record<string, unknown>)[key] = deepCloneCustom((obj as Record<string, unknown>)[key], options, depth + 1);\n  });\n  \n  if (includeSymbols) {\n    Object.getOwnPropertySymbols(obj).forEach(symbol => {\n      (clonedObj as Record<symbol, unknown>)[symbol] = deepCloneCustom((obj as Record<symbol, unknown>)[symbol], options, depth + 1);\n    });\n  }\n  \n  return clonedObj;\n}\n\n// Utility metadata\nexport const metadata: UtilityMetadata = {\n  title: \"DeepClone Function\",\n  description: \"Creates deep copies of objects and arrays handling nested structures, circular references, and various JavaScript types\",\n  category: \"Data Manipulation\",\n  concepts: [\"recursion\", \"object traversal\", \"type checking\", \"memory management\"],\n  timeComplexity: \"O(n) where n is total properties/elements\",\n  spaceComplexity: \"O(d) where d is maximum depth\",\n  difficulty: \"Medium\"\n};\n\nexport const solutions: SolutionMetadata[] = [\n  {\n    name: \"deepClone\",\n    tabName: \"Basic\",\n    approach: \"Recursive deep clone with type handling\",\n    timeComplexity: \"O(n)\",\n    spaceComplexity: \"O(d)\",\n    isOptimal: true,\n    type: \"function\"\n  },\n  {\n    name: \"deepCloneWithCircularCheck\",\n    tabName: \"Circular Safe\",\n    approach: \"Deep clone with circular reference detection\",\n    timeComplexity: \"O(n)\",\n    spaceComplexity: \"O(d)\",\n    isOptimal: true,\n    type: \"function\"\n  },\n  {\n    name: \"deepCloneJSON\",\n    tabName: \"JSON\",\n    approach: \"Fast JSON-based clone (limited type support)\",\n    timeComplexity: \"O(n)\",\n    spaceComplexity: \"O(n)\",\n    isOptimal: false,\n    type: \"function\"\n  },\n  {\n    name: \"deepCloneStructured\",\n    tabName: \"Structured\",\n    approach: \"Native structured clone API (modern environments)\",\n    timeComplexity: \"O(n)\",\n    spaceComplexity: \"O(n)\",\n    isOptimal: true,\n    type: \"function\"\n  }\n];\n\n// Example use cases\nexport const examples: UtilityExample[] = [\n  {\n    input: \"{ a: { b: [1, 2] } }\",\n    output: \"independent copy\",\n    description: \"Basic object and array deep cloning\",\n    code: `const original = {\n  user: {\n    name: 'John',\n    hobbies: ['reading', 'coding'],\n    settings: {\n      theme: 'dark',\n      notifications: true\n    }\n  }\n};\n\nconst cloned = deepClone(original);\n\n// Modify cloned object\ncloned.user.name = 'Jane';\ncloned.user.hobbies.push('gaming');\ncloned.user.settings.theme = 'light';\n\nconsole.log(original.user.name);           // 'John' (unchanged)\nconsole.log(original.user.hobbies);        // ['reading', 'coding'] (unchanged)\nconsole.log(original.user.settings.theme); // 'dark' (unchanged)\n\nconsole.log(cloned.user.name);             // 'Jane'\nconsole.log(cloned.user.hobbies);          // ['reading', 'coding', 'gaming']\nconsole.log(cloned.user.settings.theme);   // 'light'`\n  },\n  {\n    input: \"circular reference\",\n    output: \"safe clone\",\n    description: \"Handling circular references safely\",\n    code: `const obj: any = { name: 'parent' };\nobj.child = { name: 'child', parent: obj };\n\n// This would cause infinite recursion with basic deepClone\n// const broken = deepClone(obj); // Stack overflow!\n\n// Safe cloning with circular reference detection\nconst safeClone = deepCloneWithCircularCheck(obj);\n\nconsole.log(safeClone.name);              // 'parent'\nconsole.log(safeClone.child.name);        // 'child'\nconsole.log(safeClone.child.parent === safeClone); // true (maintains reference)\n\n// Modify without affecting original\nsafeClone.child.name = 'modified child';\nconsole.log(obj.child.name);              // 'child' (unchanged)`\n  },\n  {\n    input: \"complex data types\",\n    output: \"type-preserved clone\",\n    description: \"Cloning various JavaScript data types\",\n    code: `const complexObj = {\n  date: new Date('2024-01-01'),\n  regex: /test\\\\d+/gi,\n  set: new Set([1, 2, 3]),\n  map: new Map([['key1', 'value1'], ['key2', 'value2']]),\n  nested: {\n    array: [{ id: 1 }, { id: 2 }],\n    nullValue: null,\n    undefinedValue: undefined\n  }\n};\n\nconst cloned = deepClone(complexObj);\n\n// Verify types are preserved\nconsole.log(cloned.date instanceof Date);     // true\nconsole.log(cloned.regex instanceof RegExp);  // true\nconsole.log(cloned.set instanceof Set);       // true\nconsole.log(cloned.map instanceof Map);       // true\n\n// Verify independence\ncloned.set.add(4);\ncloned.map.set('key3', 'value3');\ncloned.nested.array.push({ id: 3 });\n\nconsole.log(complexObj.set.size);             // 3 (unchanged)\nconsole.log(complexObj.map.size);             // 2 (unchanged)\nconsole.log(complexObj.nested.array.length);  // 2 (unchanged)`\n  },\n  {\n    input: \"performance comparison\",\n    output: \"method selection\",\n    description: \"Choosing the right cloning method for your use case\",\n    code: `const testData = {\n  users: Array.from({ length: 1000 }, (_, i) => ({\n    id: i,\n    name: \\`User \\${i}\\`,\n    active: i % 2 === 0\n  }))\n};\n\n// JSON clone: Fastest but limited (no Dates, RegExp, etc.)\nconsole.time('JSON clone');\nconst jsonCloned = deepCloneJSON(testData);\nconsole.timeEnd('JSON clone');\n\n// Basic deep clone: Good balance of features and performance\nconsole.time('Deep clone');\nconst deepCloned = deepClone(testData);\nconsole.timeEnd('Deep clone');\n\n// Structured clone: Native browser/Node.js API (most robust)\nif (typeof structuredClone === 'function') {\n  console.time('Structured clone');\n  const structuredCloned = deepCloneStructured(testData);\n  console.timeEnd('Structured clone');\n}\n\n// Use JSON for simple objects without special types\n// Use deepClone for most cases with mixed data types\n// Use structuredClone for maximum robustness in modern environments`\n  }\n];\n\n// Default export for easy importing\nconst utilityModule = {\n  deepClone,\n  deepCloneWithCircularCheck,\n  deepCloneJSON,\n  deepCloneStructured,\n  shallowClone,\n  deepCloneCustom,\n  metadata,\n  solutions,\n  examples\n};\n\nexport default utilityModule;","functions":["deepClone","deepCloneWithCircularCheck","deepCloneJSON","deepCloneStructured","shallowClone","deepCloneCustom"],"solutions":[{"name":"deepClone","tabName":"Basic","code":"export function deepClone<T>(obj: T): T {\n  // Handle primitive types and null\n  if (obj === null || typeof obj !== 'object') {\n    return obj;\n  }\n  \n  // Handle Date\n  if (obj instanceof Date) {\n    return new Date(obj.getTime()) as T;\n  }\n  \n  // Handle RegExp\n  if (obj instanceof RegExp) {\n    return new RegExp(obj.source, obj.flags) as T;\n  }\n  \n  // Handle Array\n  if (Array.isArray(obj)) {\n    return obj.map(item => deepClone(item)) as T;\n  }\n  \n  // Handle Set\n  if (obj instanceof Set) {\n    const clonedSet = new Set();\n    obj.forEach(value => clonedSet.add(deepClone(value)));\n    return clonedSet as T;\n  }\n  \n  // Handle Map\n  if (obj instanceof Map) {\n    const clonedMap = new Map();\n    obj.forEach((value, key) => clonedMap.set(deepClone(key), deepClone(value)));\n    return clonedMap as T;\n  }\n  \n  // Handle plain objects\n  if (obj.constructor === Object) {\n    const clonedObj = {} as T;\n    for (const key in obj) {\n      if (Object.prototype.hasOwnProperty.call(obj, key)) {\n        (clonedObj as Record<string, unknown>)[key] = deepClone((obj as Record<string, unknown>)[key]);\n      }\n    }\n    return clonedObj;\n  }\n  \n  // For other objects, return as-is (functions, classes, etc.)\n  return obj;\n}\n\n// Deep clone with circular reference detection","approach":"Basic","timeComplexity":"O(n)","spaceComplexity":"O(d)","isOptimal":true,"type":"function"},{"name":"deepCloneWithCircularCheck","tabName":"Circular Safe","code":"export function deepCloneWithCircularCheck<T>(obj: T, seen = new WeakMap()): T {\n  // Handle primitive types and null\n  if (obj === null || typeof obj !== 'object') {\n    return obj;\n  }\n  \n  // Check for circular reference\n  if (seen.has(obj as object)) {\n    return seen.get(obj as object);\n  }\n  \n  // Handle Date\n  if (obj instanceof Date) {\n    const cloned = new Date(obj.getTime()) as T;\n    seen.set(obj as object, cloned);\n    return cloned;\n  }\n  \n  // Handle RegExp\n  if (obj instanceof RegExp) {\n    const cloned = new RegExp(obj.source, obj.flags) as T;\n    seen.set(obj as object, cloned);\n    return cloned;\n  }\n  \n  // Handle Array\n  if (Array.isArray(obj)) {\n    const clonedArray: unknown[] = [];\n    seen.set(obj as object, clonedArray);\n    obj.forEach((item, index) => {\n      clonedArray[index] = deepCloneWithCircularCheck(item, seen);\n    });\n    return clonedArray as T;\n  }\n  \n  // Handle Set\n  if (obj instanceof Set) {\n    const clonedSet = new Set();\n    seen.set(obj as object, clonedSet);\n    obj.forEach(value => clonedSet.add(deepCloneWithCircularCheck(value, seen)));\n    return clonedSet as T;\n  }\n  \n  // Handle Map\n  if (obj instanceof Map) {\n    const clonedMap = new Map();\n    seen.set(obj as object, clonedMap);\n    obj.forEach((value, key) => {\n      clonedMap.set(\n        deepCloneWithCircularCheck(key, seen),\n        deepCloneWithCircularCheck(value, seen)\n      );\n    });\n    return clonedMap as T;\n  }\n  \n  // Handle plain objects\n  if (obj.constructor === Object) {\n    const clonedObj = {} as T;\n    seen.set(obj as object, clonedObj);\n    for (const key in obj) {\n      if (Object.prototype.hasOwnProperty.call(obj, key)) {\n        (clonedObj as Record<string, unknown>)[key] = deepCloneWithCircularCheck((obj as Record<string, unknown>)[key], seen);\n      }\n    }\n    return clonedObj;\n  }\n  \n  // For other objects, return as-is\n  seen.set(obj as object, obj);\n  return obj;\n}\n\n// JSON-based deep clone (fast but limited)","approach":"Circular Safe","timeComplexity":"O(n)","spaceComplexity":"O(d)","isOptimal":true,"type":"function"},{"name":"deepCloneJSON","tabName":"JSON","code":"export function deepCloneJSON<T>(obj: T): T {\n  try {\n    return JSON.parse(JSON.stringify(obj));\n  } catch (error) {\n    throw new Error(`JSON deep clone failed: ${(error as Error).message}`);\n  }\n}\n\n// Structured clone API (modern browsers/Node.js)","approach":"JSON","timeComplexity":"O(n)","spaceComplexity":"O(n)","isOptimal":false,"type":"function"},{"name":"deepCloneStructured","tabName":"Structured","code":"export function deepCloneStructured<T>(obj: T): T {\n  if (typeof structuredClone === 'function') {\n    try {\n      return structuredClone(obj);\n    } catch (error) {\n      throw new Error(`Structured clone failed: ${(error as Error).message}`);\n    }\n  }\n  throw new Error('structuredClone is not available in this environment');\n}\n\n// Shallow clone for comparison","approach":"Structured","timeComplexity":"O(n)","spaceComplexity":"O(n)","isOptimal":true,"type":"function"}]}