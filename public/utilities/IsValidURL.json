{"name":"IsValidURL","slug":"IsValidURL","metadata":{"title":"IsValidURL Function","description":"Comprehensive URL validation with multiple strategies including native URL API and regex patterns","category":"Validation","concepts":["URL parsing","regular expressions","web standards","input validation"],"timeComplexity":"O(n) where n is URL length","spaceComplexity":"O(1) constant space","difficulty":"Easy","examples":["isValidURL('https://example.com') → true"],"performanceNotes":"- Time: O(n) where n is URL string length\n - Space: O(1) constant space"},"examples":[{"input":"'https://example.com'","output":"true","description":"Basic URL validation","code":"// Valid URLs\nisValidURL('https://example.com');              // true\nisValidURL('http://subdomain.example.org');     // true\nisValidURL('ftp://files.example.com');          // true\nisValidURL('https://example.com/path?q=test');  // true\n\n// Invalid URLs\nisValidURL('');                                 // false\nisValidURL('not-a-url');                        // false\nisValidURL('javascript:alert(1)');              // false\nisValidURL('file:///etc/passwd');               // false"},{"input":"form validation","output":"validation result","description":"Form URL validation with HTTPS requirement","code":"interface WebsiteForm {\n  name: string;\n  website: string;\n}\n\nfunction validateWebsiteForm(form: WebsiteForm): string[] {\n  const errors: string[] = [];\n  \n  if (!form.name.trim()) {\n    errors.push('Name is required');\n  }\n  \n  if (!form.website.trim()) {\n    errors.push('Website URL is required');\n  } else if (!isValidHTTPSURL(form.website)) {\n    errors.push('Website must be a valid HTTPS URL');\n  }\n  \n  return errors;\n}\n\nconst form = { name: 'Company', website: 'http://insecure.com' };\nconst errors = validateWebsiteForm(form);\n// ['Website must be a valid HTTPS URL']"},{"input":"'invalid-url'","output":"detailed validation","description":"Detailed URL validation with error reporting","code":"const result = validateURLDetailed('invalid-url');\nconsole.log(result);\n// {\n//   isValid: false,\n//   errors: ['Invalid URL format: Invalid URL']\n// }\n\nconst result2 = validateURLDetailed('javascript://evil.com');\nconsole.log(result2);\n// {\n//   isValid: false,\n//   protocol: 'javascript:',\n//   hostname: 'evil.com',\n//   errors: [\"Protocol 'javascript:' is not allowed\"]\n// }\n\n// Use for detailed feedback\nfunction getURLFeedback(url: string): string {\n  const validation = validateURLDetailed(url);\n  if (validation.isValid) {\n    return `Valid ${validation.protocol} URL`;\n  }\n  return validation.errors.join('; ');\n}"},{"input":"development URLs","output":"environment detection","description":"Development vs production URL handling","code":"const urls = [\n  'https://production.com',\n  'http://localhost:3000',\n  'https://127.0.0.1:8080',\n  'http://192.168.1.100',\n  'https://staging.local'\n];\n\n// Separate development from production URLs\nconst productionUrls = urls.filter(url => \n  isValidURL(url) && !isLocalURL(url)\n);\nconst developmentUrls = urls.filter(url => \n  isValidURL(url) && isLocalURL(url)\n);\n\nconsole.log('Production:', productionUrls);\n// ['https://production.com']\n\nconsole.log('Development:', developmentUrls);\n// ['http://localhost:3000', 'https://127.0.0.1:8080', 'http://192.168.1.100', 'https://staging.local']\n\n// Conditional validation based on environment\nfunction validateURLForEnvironment(url: string, isDevelopment: boolean): boolean {\n  if (!isValidURL(url)) return false;\n  \n  if (isDevelopment) {\n    return true; // Allow any valid URL in development\n  }\n  \n  return isValidHTTPSURL(url) && !isLocalURL(url);\n}"}],"code":"import type { UtilityMetadata, UtilityExample } from '@/interfaces/utilities';\nimport type { SolutionMetadata } from '@/interfaces/shared';\n\n/**\n * IsValidURL Utility Implementation\n * \n * DESCRIPTION:\n * Validates URLs using different validation strategies from basic regex to native URL API.\n * Supports various protocols and validation levels for different use cases.\n * \n * ENHANCED METADATA:\n * - Difficulty: Easy to Medium (URL parsing and validation logic)\n * - Solution Type: function (validation utility with URL API)\n * - Time Complexity: O(n) where n is URL length\n * - Space Complexity: O(1) constant space usage\n * - Concepts: URL parsing, Regular expressions, Web standards, Input validation\n * - Category: Data validation utility\n * \n * EXAMPLE:\n * isValidURL('https://example.com') → true\n * \n * CONCEPTS:\n * - URL parsing and validation\n * - Web standards (RFC 3986)\n * - Protocol validation\n * - Input sanitization\n * \n * PERFORMANCE:\n * - Time: O(n) where n is URL string length\n * - Space: O(1) constant space\n * \n * Multiple implementations included to show different validation approaches.\n */\n\n// Basic URL validation using native URL constructor\nexport function isValidURL(url: string): boolean {\n  if (typeof url !== 'string') return false;\n  if (url.length === 0 || url.length > 2083) return false; // IE limit\n  \n  try {\n    const urlObj = new URL(url);\n    return ['http:', 'https:', 'ftp:', 'ftps:'].includes(urlObj.protocol);\n  } catch {\n    return false;\n  }\n}\n\n// Strict HTTPS-only URL validation\nexport function isValidHTTPSURL(url: string): boolean {\n  if (typeof url !== 'string') return false;\n  if (url.length === 0) return false;\n  \n  try {\n    const urlObj = new URL(url);\n    return urlObj.protocol === 'https:' && urlObj.hostname.length > 0;\n  } catch {\n    return false;\n  }\n}\n\n// URL validation with specific protocol support\nexport function isValidURLWithProtocols(url: string, allowedProtocols: string[] = ['http:', 'https:']): boolean {\n  if (typeof url !== 'string') return false;\n  if (url.length === 0) return false;\n  \n  try {\n    const urlObj = new URL(url);\n    return allowedProtocols.includes(urlObj.protocol);\n  } catch {\n    return false;\n  }\n}\n\n// Regex-based URL validation (for environments without URL constructor)\nexport function isValidURLRegex(url: string): boolean {\n  if (typeof url !== 'string') return false;\n  if (url.length === 0 || url.length > 2083) return false;\n  \n  // Comprehensive URL regex pattern\n  const urlPattern = /^(https?|ftp):\\/\\/(?:[-\\w.])+(?:\\:[0-9]+)?(?:\\/(?:[\\w\\/_.])*)?(?:\\?(?:[\\w&=%.])*)?(?:\\#(?:[\\w.])*)?$/i;\n  return urlPattern.test(url);\n}\n\n// URL validation with detailed information\nexport interface URLValidationResult {\n  isValid: boolean;\n  protocol?: string;\n  hostname?: string;\n  port?: string;\n  pathname?: string;\n  search?: string;\n  hash?: string;\n  errors: string[];\n}\n\nexport function validateURLDetailed(url: string): URLValidationResult {\n  const errors: string[] = [];\n  \n  if (typeof url !== 'string') {\n    errors.push('URL must be a string');\n    return { isValid: false, errors };\n  }\n  \n  if (url.length === 0) {\n    errors.push('URL cannot be empty');\n    return { isValid: false, errors };\n  }\n  \n  if (url.length > 2083) {\n    errors.push('URL is too long (max 2083 characters)');\n  }\n  \n  try {\n    const urlObj = new URL(url);\n    \n    const result: URLValidationResult = {\n      isValid: true,\n      protocol: urlObj.protocol,\n      hostname: urlObj.hostname,\n      port: urlObj.port,\n      pathname: urlObj.pathname,\n      search: urlObj.search,\n      hash: urlObj.hash,\n      errors: []\n    };\n    \n    // Validate protocol\n    const allowedProtocols = ['http:', 'https:', 'ftp:', 'ftps:'];\n    if (!allowedProtocols.includes(urlObj.protocol)) {\n      errors.push(`Protocol '${urlObj.protocol}' is not allowed`);\n    }\n    \n    // Validate hostname\n    if (!urlObj.hostname) {\n      errors.push('URL must have a hostname');\n    } else if (urlObj.hostname.length > 253) {\n      errors.push('Hostname is too long (max 253 characters)');\n    }\n    \n    // Validate port\n    if (urlObj.port) {\n      const portNum = parseInt(urlObj.port, 10);\n      if (portNum < 1 || portNum > 65535) {\n        errors.push('Port must be between 1 and 65535');\n      }\n    }\n    \n    result.isValid = errors.length === 0;\n    result.errors = errors;\n    return result;\n    \n  } catch (error) {\n    errors.push(`Invalid URL format: ${(error as Error).message}`);\n    return { isValid: false, errors };\n  }\n}\n\n// Simple URL validation for web URLs only\nexport function isValidWebURL(url: string): boolean {\n  if (typeof url !== 'string') return false;\n  \n  try {\n    const urlObj = new URL(url);\n    return ['http:', 'https:'].includes(urlObj.protocol) && \n           urlObj.hostname.includes('.') &&\n           urlObj.hostname.length > 0;\n  } catch {\n    return false;\n  }\n}\n\n// URL validation that accepts relative URLs when base is provided\nexport function isValidURLOrRelative(url: string, base?: string): boolean {\n  if (typeof url !== 'string') return false;\n  if (url.length === 0) return false;\n  \n  try {\n    // Try as absolute URL first\n    const urlObj = new URL(url);\n    return ['http:', 'https:', 'ftp:', 'ftps:'].includes(urlObj.protocol);\n  } catch {\n    // Try as relative URL with base\n    if (base) {\n      try {\n        new URL(url, base);\n        return true;\n      } catch {\n        return false;\n      }\n    }\n    return false;\n  }\n}\n\n// Check if URL is localhost/development URL\nexport function isLocalURL(url: string): boolean {\n  try {\n    const urlObj = new URL(url);\n    const hostname = urlObj.hostname.toLowerCase();\n    return hostname === 'localhost' || \n           hostname === '127.0.0.1' || \n           hostname === '::1' ||\n           hostname.endsWith('.local') ||\n           hostname.startsWith('192.168.') ||\n           hostname.startsWith('10.') ||\n           (hostname.startsWith('172.') && \n            parseInt(hostname.split('.')[1], 10) >= 16 && \n            parseInt(hostname.split('.')[1], 10) <= 31);\n  } catch {\n    return false;\n  }\n}\n\n// Utility metadata\nexport const metadata: UtilityMetadata = {\n  title: \"IsValidURL Function\",\n  description: \"Comprehensive URL validation with multiple strategies including native URL API and regex patterns\",\n  category: \"Validation\",\n  concepts: [\"URL parsing\", \"regular expressions\", \"web standards\", \"input validation\"],\n  timeComplexity: \"O(n) where n is URL length\",\n  spaceComplexity: \"O(1) constant space\",\n  difficulty: \"Easy\"\n};\n\nexport const solutions: SolutionMetadata[] = [\n  {\n    name: \"isValidURL\",\n    tabName: \"Basic\",\n    approach: \"Native URL constructor with protocol validation\",\n    timeComplexity: \"O(n)\",\n    spaceComplexity: \"O(1)\",\n    isOptimal: true,\n    type: \"function\"\n  },\n  {\n    name: \"isValidHTTPSURL\",\n    tabName: \"HTTPS\",\n    approach: \"Strict HTTPS-only URL validation\",\n    timeComplexity: \"O(n)\",\n    spaceComplexity: \"O(1)\",\n    isOptimal: true,\n    type: \"function\"\n  },\n  {\n    name: \"isValidURLRegex\",\n    tabName: \"Regex\",\n    approach: \"Regex-based validation for legacy environments\",\n    timeComplexity: \"O(n)\",\n    spaceComplexity: \"O(1)\",\n    isOptimal: false,\n    type: \"function\"\n  },\n  {\n    name: \"validateURLDetailed\",\n    tabName: \"Detailed\",\n    approach: \"Comprehensive validation with detailed error reporting\",\n    timeComplexity: \"O(n)\",\n    spaceComplexity: \"O(k)\",\n    isOptimal: false,\n    type: \"function\"\n  }\n];\n\n// Example use cases\nexport const examples: UtilityExample[] = [\n  {\n    input: \"'https://example.com'\",\n    output: \"true\",\n    description: \"Basic URL validation\",\n    code: `// Valid URLs\nisValidURL('https://example.com');              // true\nisValidURL('http://subdomain.example.org');     // true\nisValidURL('ftp://files.example.com');          // true\nisValidURL('https://example.com/path?q=test');  // true\n\n// Invalid URLs\nisValidURL('');                                 // false\nisValidURL('not-a-url');                        // false\nisValidURL('javascript:alert(1)');              // false\nisValidURL('file:///etc/passwd');               // false`\n  },\n  {\n    input: \"form validation\",\n    output: \"validation result\",\n    description: \"Form URL validation with HTTPS requirement\",\n    code: `interface WebsiteForm {\n  name: string;\n  website: string;\n}\n\nfunction validateWebsiteForm(form: WebsiteForm): string[] {\n  const errors: string[] = [];\n  \n  if (!form.name.trim()) {\n    errors.push('Name is required');\n  }\n  \n  if (!form.website.trim()) {\n    errors.push('Website URL is required');\n  } else if (!isValidHTTPSURL(form.website)) {\n    errors.push('Website must be a valid HTTPS URL');\n  }\n  \n  return errors;\n}\n\nconst form = { name: 'Company', website: 'http://insecure.com' };\nconst errors = validateWebsiteForm(form);\n// ['Website must be a valid HTTPS URL']`\n  },\n  {\n    input: \"'invalid-url'\",\n    output: \"detailed validation\",\n    description: \"Detailed URL validation with error reporting\",\n    code: `const result = validateURLDetailed('invalid-url');\nconsole.log(result);\n// {\n//   isValid: false,\n//   errors: ['Invalid URL format: Invalid URL']\n// }\n\nconst result2 = validateURLDetailed('javascript://evil.com');\nconsole.log(result2);\n// {\n//   isValid: false,\n//   protocol: 'javascript:',\n//   hostname: 'evil.com',\n//   errors: [\"Protocol 'javascript:' is not allowed\"]\n// }\n\n// Use for detailed feedback\nfunction getURLFeedback(url: string): string {\n  const validation = validateURLDetailed(url);\n  if (validation.isValid) {\n    return \\`Valid \\${validation.protocol} URL\\`;\n  }\n  return validation.errors.join('; ');\n}`\n  },\n  {\n    input: \"development URLs\",\n    output: \"environment detection\",\n    description: \"Development vs production URL handling\",\n    code: `const urls = [\n  'https://production.com',\n  'http://localhost:3000',\n  'https://127.0.0.1:8080',\n  'http://192.168.1.100',\n  'https://staging.local'\n];\n\n// Separate development from production URLs\nconst productionUrls = urls.filter(url => \n  isValidURL(url) && !isLocalURL(url)\n);\nconst developmentUrls = urls.filter(url => \n  isValidURL(url) && isLocalURL(url)\n);\n\nconsole.log('Production:', productionUrls);\n// ['https://production.com']\n\nconsole.log('Development:', developmentUrls);\n// ['http://localhost:3000', 'https://127.0.0.1:8080', 'http://192.168.1.100', 'https://staging.local']\n\n// Conditional validation based on environment\nfunction validateURLForEnvironment(url: string, isDevelopment: boolean): boolean {\n  if (!isValidURL(url)) return false;\n  \n  if (isDevelopment) {\n    return true; // Allow any valid URL in development\n  }\n  \n  return isValidHTTPSURL(url) && !isLocalURL(url);\n}`\n  }\n];\n\n// Default export for easy importing\nconst utilityModule = {\n  isValidURL,\n  isValidHTTPSURL,\n  isValidURLWithProtocols,\n  isValidURLRegex,\n  validateURLDetailed,\n  isValidWebURL,\n  isValidURLOrRelative,\n  isLocalURL,\n  metadata,\n  solutions,\n  examples\n};\n\nexport default utilityModule;","functions":["isValidURL","isValidHTTPSURL","isValidURLWithProtocols","isValidURLRegex","validateURLDetailed","isValidWebURL","isValidURLOrRelative","isLocalURL"],"solutions":[{"name":"isValidURL","tabName":"Basic","code":"export function isValidURL(url: string): boolean {\n  if (typeof url !== 'string') return false;\n  if (url.length === 0 || url.length > 2083) return false; // IE limit\n  \n  try {\n    const urlObj = new URL(url);\n    return ['http:', 'https:', 'ftp:', 'ftps:'].includes(urlObj.protocol);\n  } catch {\n    return false;\n  }\n}\n\n// Strict HTTPS-only URL validation","approach":"Basic","timeComplexity":"O(n)","spaceComplexity":"O(1)","isOptimal":true,"type":"function"},{"name":"isValidHTTPSURL","tabName":"HTTPS","code":"export function isValidHTTPSURL(url: string): boolean {\n  if (typeof url !== 'string') return false;\n  if (url.length === 0) return false;\n  \n  try {\n    const urlObj = new URL(url);\n    return urlObj.protocol === 'https:' && urlObj.hostname.length > 0;\n  } catch {\n    return false;\n  }\n}\n\n// URL validation with specific protocol support","approach":"HTTPS","timeComplexity":"O(n)","spaceComplexity":"O(1)","isOptimal":true,"type":"function"},{"name":"isValidURLRegex","tabName":"Regex","code":"export function isValidURLRegex(url: string): boolean {\n  if (typeof url !== 'string') return false;\n  if (url.length === 0 || url.length > 2083) return false;\n  \n  // Comprehensive URL regex pattern\n  const urlPattern = /^(https?|ftp):\\/\\/(?:[-\\w.])+(?:\\:[0-9]+)?(?:\\/(?:[\\w\\/_.])*)?(?:\\?(?:[\\w&=%.])*)?(?:\\#(?:[\\w.])*)?$/i;\n  return urlPattern.test(url);\n}\n\n// URL validation with detailed information","approach":"Regex","timeComplexity":"O(n)","spaceComplexity":"O(1)","isOptimal":false,"type":"function"},{"name":"validateURLDetailed","tabName":"Detailed","code":"export function validateURLDetailed(url: string): URLValidationResult {\n  const errors: string[] = [];\n  \n  if (typeof url !== 'string') {\n    errors.push('URL must be a string');\n    return { isValid: false, errors };\n  }\n  \n  if (url.length === 0) {\n    errors.push('URL cannot be empty');\n    return { isValid: false, errors };\n  }\n  \n  if (url.length > 2083) {\n    errors.push('URL is too long (max 2083 characters)');\n  }\n  \n  try {\n    const urlObj = new URL(url);\n    \n    const result: URLValidationResult = {\n      isValid: true,\n      protocol: urlObj.protocol,\n      hostname: urlObj.hostname,\n      port: urlObj.port,\n      pathname: urlObj.pathname,\n      search: urlObj.search,\n      hash: urlObj.hash,\n      errors: []\n    };\n    \n    // Validate protocol\n    const allowedProtocols = ['http:', 'https:', 'ftp:', 'ftps:'];\n    if (!allowedProtocols.includes(urlObj.protocol)) {\n      errors.push(`Protocol '${urlObj.protocol}' is not allowed`);\n    }\n    \n    // Validate hostname\n    if (!urlObj.hostname) {\n      errors.push('URL must have a hostname');\n    } else if (urlObj.hostname.length > 253) {\n      errors.push('Hostname is too long (max 253 characters)');\n    }\n    \n    // Validate port\n    if (urlObj.port) {\n      const portNum = parseInt(urlObj.port, 10);\n      if (portNum < 1 || portNum > 65535) {\n        errors.push('Port must be between 1 and 65535');\n      }\n    }\n    \n    result.isValid = errors.length === 0;\n    result.errors = errors;\n    return result;\n    \n  } catch (error) {\n    errors.push(`Invalid URL format: ${(error as Error).message}`);\n    return { isValid: false, errors };\n  }\n}\n\n// Simple URL validation for web URLs only","approach":"Detailed","timeComplexity":"O(n)","spaceComplexity":"O(k)","isOptimal":false,"type":"function"}]}