{"name":"GroupBy","slug":"GroupBy","metadata":{"title":"GroupBy Function","description":"Groups array items by a key selector function or property name","category":"Data Manipulation","concepts":["array manipulation","data grouping","functional programming","data transformation"],"timeComplexity":"O(n) where n is array length","spaceComplexity":"O(n) for grouped result","difficulty":"Easy"},"examples":[{"input":"[{type: 'A'}, {type: 'B'}], 'type'","output":"{A: [...], B: [...]}","description":"Group objects by property","code":"const users = [\n  { name: 'John', role: 'admin', age: 30 },\n  { name: 'Jane', role: 'user', age: 25 },\n  { name: 'Bob', role: 'admin', age: 35 }\n];\n\nconst byRole = groupByProperty(users, 'role');\n// { admin: [John, Bob], user: [Jane] }"}],"code":"import type { UtilityMetadata, UtilityExample } from '@/interfaces/utilities';\nimport type { SolutionMetadata } from '@/interfaces/shared';\n\nexport function groupBy<T, K extends string | number | symbol>(\n  array: T[],\n  keySelector: (item: T) => K\n): Record<K, T[]> {\n  if (!Array.isArray(array)) {\n    throw new Error('First argument must be an array');\n  }\n  \n  if (typeof keySelector !== 'function') {\n    throw new Error('Second argument must be a function');\n  }\n  \n  const result = {} as Record<K, T[]>;\n  \n  for (const item of array) {\n    const key = keySelector(item);\n    if (!result[key]) {\n      result[key] = [];\n    }\n    result[key].push(item);\n  }\n  \n  return result;\n}\n\nexport function groupByProperty<T>(\n  array: T[],\n  property: keyof T\n): Record<string, T[]> {\n  return groupBy(array, (item) => String(item[property]));\n}\n\nexport const metadata: UtilityMetadata = {\n  title: \"GroupBy Function\",\n  description: \"Groups array items by a key selector function or property name\",\n  category: \"Data Manipulation\",\n  concepts: [\"array manipulation\", \"data grouping\", \"functional programming\", \"data transformation\"],\n  timeComplexity: \"O(n) where n is array length\",\n  spaceComplexity: \"O(n) for grouped result\",\n  difficulty: \"Easy\"\n};\n\nexport const solutions: SolutionMetadata[] = [\n  {\n    name: \"groupBy\",\n    tabName: \"Function\",\n    approach: \"Group by key selector function\",\n    timeComplexity: \"O(n)\",\n    spaceComplexity: \"O(n)\",\n    isOptimal: true,\n    type: \"function\"\n  },\n  {\n    name: \"groupByProperty\",\n    tabName: \"Property\",\n    approach: \"Group by object property name\",\n    timeComplexity: \"O(n)\",\n    spaceComplexity: \"O(n)\",\n    isOptimal: true,\n    type: \"function\"\n  }\n];\n\nexport const examples: UtilityExample[] = [\n  {\n    input: \"[{type: 'A'}, {type: 'B'}], 'type'\",\n    output: \"{A: [...], B: [...]}\",\n    description: \"Group objects by property\",\n    code: `const users = [\n  { name: 'John', role: 'admin', age: 30 },\n  { name: 'Jane', role: 'user', age: 25 },\n  { name: 'Bob', role: 'admin', age: 35 }\n];\n\nconst byRole = groupByProperty(users, 'role');\n// { admin: [John, Bob], user: [Jane] }`\n  }\n];\n\nconst utilityModule = { groupBy, groupByProperty, metadata, solutions, examples };\nexport default utilityModule;","functions":["groupBy","groupByProperty"],"solutions":[{"name":"groupBy","tabName":"Function","code":"export function groupBy<T, K extends string | number | symbol>(\n  array: T[],\n  keySelector: (item: T) => K\n): Record<K, T[]> {\n  if (!Array.isArray(array)) {\n    throw new Error('First argument must be an array');\n  }\n  \n  if (typeof keySelector !== 'function') {\n    throw new Error('Second argument must be a function');\n  }\n  \n  const result = {} as Record<K, T[]>;\n  \n  for (const item of array) {\n    const key = keySelector(item);\n    if (!result[key]) {\n      result[key] = [];\n    }\n    result[key].push(item);\n  }\n  \n  return result;\n}","approach":"Function","timeComplexity":"O(n)","spaceComplexity":"O(n)","isOptimal":true,"type":"function"},{"name":"groupByProperty","tabName":"Property","code":"export function groupByProperty<T>(\n  array: T[],\n  property: keyof T\n): Record<string, T[]> {\n  return groupBy(array, (item) => String(item[property]));\n}","approach":"Property","timeComplexity":"O(n)","spaceComplexity":"O(n)","isOptimal":true,"type":"function"}]}