{"name":"Curry","slug":"Curry","metadata":{"title":"Curry Function","description":"Transforms functions to enable partial application, converting multi-argument functions into sequences of single-argument functions","category":"Functional Programming","concepts":["closures","higher-order functions","functional programming","partial application"],"timeComplexity":"O(1) per curried call","spaceComplexity":"O(n) where n is argument count","difficulty":"Medium","examples":["curry(add)(1)(2) → 3 (where add = (a, b) => a + b)"],"performanceNotes":"- Time: O(1) per curried call\n - Space: O(n) where n is the number of arguments accumulated"},"examples":[{"input":"add(1, 2)","output":"3","description":"Basic function currying","code":"const add = (a: number, b: number) => a + b;\nconst curriedAdd = curry(add);\n\n// All equivalent calls:\ncurriedAdd(1)(2);        // 3\ncurriedAdd(1, 2);        // 3\n\n// Partial application:\nconst addOne = curriedAdd(1);\naddOne(2);               // 3"},{"input":"multiply(2, 3, 4)","output":"24","description":"Multi-argument function currying","code":"const multiply = (a: number, b: number, c: number) => a * b * c;\nconst curriedMultiply = autoCurry(multiply);\n\n// Flexible partial application:\nconst double = curriedMultiply(2);\nconst doubleTriple = double(3);\ndoubleTriple(4);         // 24\n\n// Or all at once:\ncurriedMultiply(2)(3)(4); // 24"},{"input":"map(double, [1,2,3])","output":"[2,4,6]","description":"Functional programming patterns","code":"const map = <T, U>(fn: (item: T) => U, array: T[]) => array.map(fn);\nconst curriedMap = curry2(map);\n\nconst double = (x: number) => x * 2;\nconst mapDouble = curriedMap(double);\n\nmapDouble([1, 2, 3]);    // [2, 4, 6]\nmapDouble([4, 5, 6]);    // [8, 10, 12]\n\n// Compose with other functions:\nconst numbers = [1, 2, 3, 4, 5];\nconst doubledEvens = numbers\n  .filter(x => x % 2 === 0)\n  .map(double);            // Uses curried function"}],"code":"import type { UtilityMetadata, UtilityExample } from '@/interfaces/utilities';\nimport type { SolutionMetadata } from '@/interfaces/shared';\n\n/**\n * Curry Utility Implementation\n * \n * DESCRIPTION:\n * Transforms a function to enable partial application by converting a function\n * that takes multiple arguments into a sequence of functions that each take a single argument.\n * \n * ENHANCED METADATA:\n * - Difficulty: Medium (functional programming concepts)\n * - Solution Type: function (higher-order function implementation)\n * - Time Complexity: O(1) per curried call\n * - Space Complexity: O(n) where n is the number of arguments\n * - Concepts: Closures, Higher-order functions, Functional programming, Partial application\n * - Category: Functional programming utility\n * \n * EXAMPLE:\n * curry(add)(1)(2) → 3 (where add = (a, b) => a + b)\n * \n * CONCEPTS:\n * - Closures and lexical scoping\n * - Higher-order functions\n * - Functional programming paradigms\n * - Partial application\n * - Function composition\n * \n * PERFORMANCE:\n * - Time: O(1) per curried call\n * - Space: O(n) where n is the number of arguments accumulated\n * \n * Multiple implementations included to show different approaches.\n */\n\n// Basic curry implementation\nexport function curry<T extends (...args: unknown[]) => unknown>(fn: T): T {\n  const arity = fn.length;\n  \n  function curried(...args: unknown[]): unknown {\n    if (args.length >= arity) {\n      return fn(...args);\n    }\n    return (...nextArgs: unknown[]) => curried(...args, ...nextArgs);\n  }\n  \n  return curried as T;\n}\n\n// Auto-curry with flexible arity\nexport function autoCurry<T extends (...args: unknown[]) => unknown>(fn: T): T {\n  const arity = fn.length;\n  \n  function curried(...args: unknown[]): unknown {\n    if (args.length >= arity) {\n      return fn(...args);\n    }\n    return (...nextArgs: unknown[]) => curried(...args, ...nextArgs);\n  }\n  \n  return curried as T;\n}\n\n// Simple curry for binary functions\nexport function curry2<A, B, R>(fn: (a: A, b: B) => R): (a: A) => (b: B) => R {\n  return (a: A) => (b: B) => fn(a, b);\n}\n\n// Simple curry for ternary functions\nexport function curry3<A, B, C, R>(fn: (a: A, b: B, c: C) => R): (a: A) => (b: B) => (c: C) => R {\n  return (a: A) => (b: B) => (c: C) => fn(a, b, c);\n}\n\n// Utility metadata\nexport const metadata: UtilityMetadata = {\n  title: \"Curry Function\",\n  description: \"Transforms functions to enable partial application, converting multi-argument functions into sequences of single-argument functions\",\n  category: \"Functional Programming\",\n  concepts: [\"closures\", \"higher-order functions\", \"functional programming\", \"partial application\"],\n  timeComplexity: \"O(1) per curried call\",\n  spaceComplexity: \"O(n) where n is argument count\",\n  difficulty: \"Medium\"\n};\n\nexport const solutions: SolutionMetadata[] = [\n  {\n    name: \"curry\",\n    tabName: \"Basic\",\n    approach: \"TypeScript-safe curry with automatic arity detection\",\n    timeComplexity: \"O(1)\",\n    spaceComplexity: \"O(n)\",\n    isOptimal: true,\n    type: \"function\"\n  },\n  {\n    name: \"autoCurry\",\n    tabName: \"Auto\",\n    approach: \"Flexible curry that handles any arity automatically\",\n    timeComplexity: \"O(1)\",\n    spaceComplexity: \"O(n)\",\n    isOptimal: true,\n    type: \"function\"\n  },\n  {\n    name: \"curry2\",\n    tabName: \"Binary\",\n    approach: \"Simple curry for two-argument functions\",\n    timeComplexity: \"O(1)\",\n    spaceComplexity: \"O(1)\",\n    isOptimal: true,\n    type: \"function\"\n  },\n  {\n    name: \"curry3\",\n    tabName: \"Ternary\",\n    approach: \"Simple curry for three-argument functions\",\n    timeComplexity: \"O(1)\",\n    spaceComplexity: \"O(1)\",\n    isOptimal: true,\n    type: \"function\"\n  }\n];\n\n// Example use cases\nexport const examples: UtilityExample[] = [\n  {\n    input: \"add(1, 2)\",\n    output: \"3\",\n    description: \"Basic function currying\",\n    code: `const add = (a: number, b: number) => a + b;\nconst curriedAdd = curry(add);\n\n// All equivalent calls:\ncurriedAdd(1)(2);        // 3\ncurriedAdd(1, 2);        // 3\n\n// Partial application:\nconst addOne = curriedAdd(1);\naddOne(2);               // 3`\n  },\n  {\n    input: \"multiply(2, 3, 4)\",\n    output: \"24\",\n    description: \"Multi-argument function currying\",\n    code: `const multiply = (a: number, b: number, c: number) => a * b * c;\nconst curriedMultiply = autoCurry(multiply);\n\n// Flexible partial application:\nconst double = curriedMultiply(2);\nconst doubleTriple = double(3);\ndoubleTriple(4);         // 24\n\n// Or all at once:\ncurriedMultiply(2)(3)(4); // 24`\n  },\n  {\n    input: \"map(double, [1,2,3])\",\n    output: \"[2,4,6]\",\n    description: \"Functional programming patterns\",\n    code: `const map = <T, U>(fn: (item: T) => U, array: T[]) => array.map(fn);\nconst curriedMap = curry2(map);\n\nconst double = (x: number) => x * 2;\nconst mapDouble = curriedMap(double);\n\nmapDouble([1, 2, 3]);    // [2, 4, 6]\nmapDouble([4, 5, 6]);    // [8, 10, 12]\n\n// Compose with other functions:\nconst numbers = [1, 2, 3, 4, 5];\nconst doubledEvens = numbers\n  .filter(x => x % 2 === 0)\n  .map(double);            // Uses curried function`\n  }\n];\n\n// Default export for easy importing\nconst utilityModule = {\n  curry,\n  autoCurry,\n  curry2,\n  curry3,\n  metadata,\n  solutions,\n  examples\n};\n\nexport default utilityModule;","functions":["curry","autoCurry","curry2","curry3"],"solutions":[{"name":"curry","tabName":"Basic","code":"export function curry<T extends (...args: unknown[]) => unknown>(fn: T): T {\n  const arity = fn.length;\n  \n  function curried(...args: unknown[]): unknown {\n    if (args.length >= arity) {\n      return fn(...args);\n    }\n    return (...nextArgs: unknown[]) => curried(...args, ...nextArgs);\n  }\n  \n  return curried as T;\n}\n\n// Auto-curry with flexible arity","approach":"Basic","timeComplexity":"O(1)","spaceComplexity":"O(n)","isOptimal":true,"type":"function"},{"name":"autoCurry","tabName":"Auto","code":"export function autoCurry<T extends (...args: unknown[]) => unknown>(fn: T): T {\n  const arity = fn.length;\n  \n  function curried(...args: unknown[]): unknown {\n    if (args.length >= arity) {\n      return fn(...args);\n    }\n    return (...nextArgs: unknown[]) => curried(...args, ...nextArgs);\n  }\n  \n  return curried as T;\n}\n\n// Simple curry for binary functions","approach":"Auto","timeComplexity":"O(1)","spaceComplexity":"O(n)","isOptimal":true,"type":"function"},{"name":"curry2","tabName":"Binary","code":"export function curry2<A, B, R>(fn: (a: A, b: B) => R): (a: A) => (b: B) => R {\n  return (a: A) => (b: B) => fn(a, b);\n}\n\n// Simple curry for ternary functions","approach":"Binary","timeComplexity":"O(1)","spaceComplexity":"O(1)","isOptimal":true,"type":"function"},{"name":"curry3","tabName":"Ternary","code":"export function curry3<A, B, C, R>(fn: (a: A, b: B, c: C) => R): (a: A) => (b: B) => (c: C) => R {\n  return (a: A) => (b: B) => (c: C) => fn(a, b, c);\n}\n\n// Utility metadata","approach":"Ternary","timeComplexity":"O(1)","spaceComplexity":"O(1)","isOptimal":true,"type":"function"}]}